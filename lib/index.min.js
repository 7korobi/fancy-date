(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define([], factory);
	else if(typeof exports === 'object')
		exports["VuePetitStore"] = factory();
	else
		root["VuePetitStore"] = factory();
})(global, function() {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./src/index.coffee");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./src/curtain.coffee":
/*!****************************!*\
  !*** ./src/curtain.coffee ***!
  \****************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _;

_ = __webpack_require__(/*! lodash */ "lodash");
module.exports = {
  curtain: function (id) {
    var bottom_id, calc_id, left_id, right_id, space_id, spots_id, top_id;
    spots_id = `${id}_spots`;
    space_id = `${id}_space`;
    calc_id = `${id}_calc`;
    left_id = `${id}_left`;
    top_id = `${id}_top`;
    right_id = `${id}_right`;
    bottom_id = `${id}_bottom`;
    return {
      directives: {
        [id]: {
          bind: function (el, binding, {
            context
          }) {
            var base, vm;
            vm = context;

            if ((base = vm.$refs)[id] == null) {
              base[id] = [];
            }

            return vm.$refs[id].push(el);
          }
        }
      },
      data: function () {
        var bottom, left, right, top;
        left = top = -2e308;
        right = bottom = 2e308;
        return {
          [spots_id]: [],
          [id]: {
            left,
            top,
            right,
            bottom
          }
        };
      },
      computed: {
        [left_id]: function () {
          var i, len, o, ref, results;
          ref = this[spots_id];
          results = [];

          for (i = 0, len = ref.length; i < len; i++) {
            o = ref[i];
            results.push(o.left < this[id].left);
          }

          return results;
        },
        [top_id]: function () {
          var i, len, o, ref, results;
          ref = this[spots_id];
          results = [];

          for (i = 0, len = ref.length; i < len; i++) {
            o = ref[i];
            results.push(o.top < this[id].top);
          }

          return results;
        },
        [right_id]: function () {
          var i, len, o, ref, results;
          ref = this[spots_id];
          results = [];

          for (i = 0, len = ref.length; i < len; i++) {
            o = ref[i];
            results.push(this[id].right < o.right);
          }

          return results;
        },
        [bottom_id]: function () {
          var i, len, o, ref, results;
          ref = this[spots_id];
          results = [];

          for (i = 0, len = ref.length; i < len; i++) {
            o = ref[i];
            results.push(this[id].bottom < o.bottom);
          }

          return results;
        },
        [space_id]: function () {
          var enter, leave, move;

          enter = () => {
            return this[calc_id]();
          };

          leave = () => {
            var bottom, left, right, top;
            left = top = 0;
            right = bottom = 2e308;
            return this[id] = {
              left,
              top,
              right,
              bottom
            };
          };

          move = e => {
            var bottom, left, ref, ref1, ref2, ref3, ref4, ref5, right, top;
            left = right = (ref = e.pageX) != null ? ref : (ref1 = e.changedTouches) != null ? (ref2 = ref1[0]) != null ? ref2.pageX : void 0 : void 0;
            top = bottom = (ref3 = e.pageY) != null ? ref3 : (ref4 = e.changedTouches) != null ? (ref5 = ref4[0]) != null ? ref5.pageY : void 0 : void 0;
            return this[id] = {
              left,
              top,
              right,
              bottom
            };
          };

          return {
            scroll: enter,
            touchenter: enter,
            touchmove: move,
            touchleave: leave,
            mouseenter: enter,
            mousemove: move,
            mouseleave: leave
          };
        }
      },
      methods: {
        [calc_id]: function () {
          var bottom, left, list, o, oo, right, top;

          if (!(list = this.$refs[id])) {
            return;
          }

          return this[spots_id] = function () {
            var i, len, ref, results;
            results = [];

            for (i = 0, len = list.length; i < len; i++) {
              o = list[i];

              if (oo = (ref = o.getClientRects()) != null ? ref[0] : void 0) {
                ({
                  left,
                  top,
                  right,
                  bottom
                } = oo);
              } else {
                left = top = 2e308;
                right = bottom = 0;
              }

              results.push({
                left,
                top,
                right,
                bottom
              });
            }

            return results;
          }();
        }
      }
    };
  }
};

/***/ }),

/***/ "./src/device.coffee":
/*!***************************!*\
  !*** ./src/device.coffee ***!
  \***************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var abg, abg_new, accel, accel_with_gravity, devicemotion, deviceorientation, gamepad_poll, gamepads, geo, geo_to_s, geolocation, gravity, gyro, m, mks_to_s, rotate, scroll, scroll_poll, threshold_to_s, xyz, xyz_new;

geo_to_s = function (n, mark, minus) {
  var n1, n2, n3, n4, n5;
  n1 = parseInt(n);
  n2 = parseInt(n * 60 % 60);
  n3 = parseInt(n * 3600 % 60);
  n4 = parseInt(n * 216000 % 60);
  n5 = parseInt(n * 12960000 % 60);

  if (n < 0) {
    mark = minus;
  }

  return `${n1}°${n2}′${n3}″${n4}‴${n5}⁗${mark}`;
};

mks_to_s = function (n, mark) {
  var n1, n2;
  n1 = parseInt(n);
  n2 = parseInt(n * 100 % 100);
  return `${n1}${mark}${n2}c${mark}`;
};

threshold_to_s = function (newVal, margin, keep, lo, l1, l2, l3) {
  switch (false) {
    case !(newVal < -margin):
      return l1;

    case !(margin < newVal):
      return l3;

    case !(lo === l1 && newVal < -keep):
      return l1;

    case !(lo === l3 && keep < newVal):
      return l3;

    default:
      return l2;
  }
};

xyz = function (newVal, oldVal) {
  var keep, lx, ly, lz, margin, x, y, z;
  ({
    x,
    y,
    z
  } = newVal);
  ({
    margin,
    keep
  } = m);
  margin *= 10;
  keep *= 10;
  oldVal.label_x = lx = threshold_to_s(x, margin, keep, oldVal.label_x, "右", "", "左");
  oldVal.label_y = ly = threshold_to_s(y, margin, keep, oldVal.label_y, "上", "", "下");
  oldVal.label_z = lz = threshold_to_s(z, margin, keep, oldVal.label_z, "表", "", "裏");
  oldVal.label = `${lx}${ly}${lz}`;
  oldVal.x = x;
  oldVal.y = y;
  return oldVal.z = z;
};

abg = function (newVal, oldVal) {
  var alpha, beta, gamma, keep, la, lb, lg, margin;
  ({
    alpha,
    beta,
    gamma
  } = newVal);
  ({
    margin,
    keep
  } = m);
  margin *= 360;
  keep *= 360;
  oldVal.label_alpha = la = threshold_to_s(alpha, margin, keep, oldVal.label_alpha, "押下", "", "引上");
  oldVal.label_beta = lb = threshold_to_s(beta, margin, keep, oldVal.label_beta, "左巻", "", "右巻");
  oldVal.label_gamma = lg = threshold_to_s(gamma, margin, keep, oldVal.label_gamma, "右折", "", "左折");
  oldVal.label = `${la}${lb}${lg}`;
  oldVal.alpha = alpha;
  oldVal.beta = beta;
  return oldVal.gamma = gamma;
};

xyz_new = function () {
  return {
    x: 0,
    y: 0,
    z: 0,
    label: "",
    label_x: "",
    label_y: "",
    label_z: ""
  };
};

abg_new = function () {
  return {
    alpha: 0,
    beta: 0,
    gamma: 0,
    absolute: 0,
    label: "",
    label_alpha: "",
    label_beta: "",
    label_gamma: ""
  };
};

accel = xyz_new();
gravity = xyz_new();
accel_with_gravity = xyz_new();
gyro = abg_new();
rotate = abg_new();
gamepads = [];
geo = {
  label: "",
  latitude: 0,
  longitude: 0,
  altitude: 0,
  heading: 0,
  speed: 0
};
scroll = {
  top: 0,
  center: 0,
  bottom: 0,
  left: 0,
  right: 0,
  horizon: 0,
  height: 0,
  width: 0,
  size: 0,
  aspect_ratio: 1,
  is_square: true,
  is_oblong: false,
  is_horizontal: true,
  is_vertical: false
};
deviceorientation = {
  count: 0,
  call: function ({
    alpha,
    beta,
    gamma,
    absolute
  }) {
    gyro.alpha = alpha;
    gyro.beta = beta;
    gyro.gamma = gamma;
    return gyro.absolute = absolute;
  },
  with: function (o) {
    return Object.assign(o, {
      mounted: () => {
        if (typeof window === "undefined" || window === null) {
          return;
        }

        if (this.count++) {
          return;
        }

        return window.addEventListener("deviceorientation", this.call);
      },
      beforeDestroy: () => {
        if (--this.count) {
          return;
        }

        return window.removeEventListener("deviceorientation", this.call);
      }
    });
  }
};
devicemotion = {
  count: 0,
  call: function ({
    interval,
    acceleration,
    accelerationIncludingGravity,
    rotationRate
  }) {
    var calc_gravity;
    calc_gravity = {
      x: accelerationIncludingGravity.x - acceleration.x,
      y: accelerationIncludingGravity.y - acceleration.y,
      z: accelerationIncludingGravity.z - acceleration.z
    };
    xyz(acceleration, accel);
    xyz(accelerationIncludingGravity, accel_with_gravity);
    xyz(calc_gravity, gravity);
    return abg(rotationRate, rotate);
  },
  with: function (o) {
    return Object.assign(o, {
      mounted: () => {
        if (typeof window === "undefined" || window === null) {
          return;
        }

        if (this.count++) {
          return;
        }

        return window.addEventListener("devicemotion", this.call);
      },
      beforeDestroy: () => {
        if (--this.count) {
          return;
        }

        return window.removeEventListener("devicemotion", this.call);
      }
    });
  }
};
geolocation = {
  watch_id: null,
  count: 0,
  call: function ({
    coords,
    timestamp
  }) {
    var accuracy, altitude, altitudeAccuracy, heading, latitude, longitude, speed;
    ({
      accuracy,
      altitudeAccuracy,
      latitude,
      longitude,
      altitude,
      heading,
      speed
    } = coords);

    if (altitude == null) {
      altitude = 0;
    }

    geo.label = `${geo_to_s(longitude, 'N', 'S')} ${geo_to_s(latitude, 'E', 'W')} ${mks_to_s(altitude, 'm')}`;
    geo.longitude = longitude;
    geo.latitude = latitude;
    geo.altitude = altitude;
    geo.heading = heading;
    return geo.speed = speed;
  },
  with: function (o) {
    return Object.assign(o, {
      mounted: () => {
        if ((typeof navigator !== "undefined" && navigator !== null ? navigator.geolocation : void 0) == null) {
          return;
        }

        if (this.count++) {
          return;
        }

        return this.watch_id = navigator.geolocation.watchPosition(this.call, function ({
          code
        }) {
          return console.log(`watchPosition error = ${code}`);
        }, {
          enableHighAccuracy: true,
          maximumAge: 60 * 1000,
          timeout: 10 * 1000
        });
      },
      beforeDestroy: () => {
        if (--this.count) {
          return;
        }

        return navigator.geolocation.clearWatch(this.watch_id);
      }
    });
  }
};
scroll_poll = {
  count: 0,
  call: function () {
    var height, left, top, width;
    scroll.top = parseInt(scrollY);
    scroll.left = parseInt(scrollX);
    scroll.width = parseInt(innerWidth);
    scroll.height = parseInt(innerHeight);
    ({
      height,
      top,
      left,
      width
    } = scroll);

    if (width < height) {
      scroll.size = width;
      scroll.aspect_ratio = height / width;
      scroll.is_vertical = true;
      scroll.is_horizontal = false;
    } else {
      scroll.size = height;
      scroll.aspect_ratio = width / height;
      scroll.is_vertical = false;
      scroll.is_horizontal = true;
    }

    scroll.is_square = !(scroll.is_oblong = 1.35 < scroll.aspect_ratio);
    scroll.horizon = height >> 1;
    scroll.center = top + (height >> 1);
    scroll.bottom = top + height;
    scroll.right = left + width;
    return requestAnimationFrame(scroll_poll.call);
  },
  with: function (o) {
    return Object.assign(o, {
      mounted: () => {
        if (typeof window === "undefined" || window === null) {
          return;
        }

        if (this.count++) {
          return;
        }

        return this.call();
      },
      beforeDestroy: () => {}
    });
  }
};
gamepad_poll = {
  count: 0,
  conn: function ({
    gamepad: {
      timestamp,
      connected,
      buttons,
      axes
    }
  }) {
    var index;
    ({
      index,
      timestamp,
      connected,
      buttons,
      axes
    } = gamepad);
    gamepads[index] = gamepad;

    if (connected) {} else {}
  },
  // bye
  // join
  call: function () {
    var gamepad, i, index, len, ref;

    if (!window.ongamepadconnected) {
      ref = navigator.getGamepads();

      for (i = 0, len = ref.length; i < len; i++) {
        gamepad = ref[i];
        ({
          index
        } = gamepad);
        gamepads[index] = gamepad;
      }
    }

    return requestAnimationFrame(gamepad_poll.call);
  },
  with: function (o) {
    return Object.assign(o, {
      mounted: () => {
        if (typeof window === "undefined" || window === null) {
          return;
        }

        if (this.count++) {
          return;
        }

        this.call();

        if (window.ongamepadconnected) {
          window.addEventListener("gamepadconnected", this.conn);
          return window.addEventListener("gamepaddisconnected", this.conn);
        }
      },
      beforeDestroy: () => {
        if (--this.count) {
          return;
        }

        if (window.ongamepadconnected) {
          window.removeEventListener("gamepadconnected", this.conn);
          return window.removeEventListener("gamepaddisconnected", this.conn);
        }
      }
    });
  }
};
module.exports = m = {
  margin: 0.4,
  keep: 0.1,
  device: function ({
    margin,
    keep
  }) {
    m.margin = margin;
    return m.keep = keep;
  },
  gamepad: function () {
    return gamepad_poll.with({
      data: function () {
        return {
          gamepads
        };
      }
    });
  },
  geo: function () {
    return geolocation.with({
      data: function () {
        return {
          geo
        };
      }
    });
  },
  gyro: function () {
    return deviceorientation.with({
      data: function () {
        return {
          gyro
        };
      }
    });
  },
  accel: function () {
    return devicemotion.with({
      data: function () {
        return {
          accel,
          gravity,
          accel_with_gravity
        };
      }
    });
  },
  rotate: function () {
    return devicemotion.with({
      data: function () {
        return {
          rotate
        };
      }
    });
  },
  scroll: function () {
    return scroll_poll.with({
      data: function () {
        return {
          scroll
        };
      },
      methods: {
        scroll_to: function ({
          query,
          mode
        }) {
          var el, height, top;

          if (!(el = typeof document !== "undefined" && document !== null ? document.querySelector(query) : void 0)) {
            return;
          }

          if (!({
            height,
            top
          } = el.getBoundingClientRect())) {
            return;
          }

          switch (mode) {
            case 'center':
              top += (height >> 1) - scroll.horizon;
              break;

            case 'bottom':
              top += height;
          }

          console.log(` go to ${query}(${mode}) as ${top}px`);
          return window.scrollBy(0, top);
        }
      }
    });
  }
};

/***/ }),

/***/ "./src/fancy-date-sample.coffee":
/*!**************************************!*\
  !*** ./src/fancy-date-sample.coffee ***!
  \**************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var EARTH, ERAS, FancyDate, FastEarth, GREGORIO, MARS, g, 平気法;
FancyDate = __webpack_require__(/*! ./fancy-date */ "./src/fancy-date.coffee");
EARTH = [[31556925147.0, new Date("2019/03/21 06:58").getTime()], [2551442889.6, new Date("2019/01/06 10:28").getTime()], [86400000, 0 // LOD ではなく、暦上の1日。Unix epoch では閏秒を消し去るため。
], 23.4397, [35, 135]];
MARS = [[59354347573.5373, new Date("2018/10/28 09:00").getTime()], [2551442889.6, new Date("2019/01/06 10:28").getTime()], [88775000, 0 // 24時間39分35秒。
], 25.19, [35, 0]];
FastEarth = [// 天体が地球の百倍速のケース
[315569251.470, new Date("2019/03/21 06:58").getTime() / 100], [25514428.896, new Date("2019/01/06 10:28").getTime() / 100], [864000, 0 // LOD ではなく、暦上の1日。Unix epoch では閏秒を消し去るため。
], 23.4397, [35, 135]];
ERAS = [["大化", -41795611200000 - 75600000], ["白雉", -41647953600000 - 75600000], ["朱鳥", -40499352000000 - 75600000], ["大宝", -40034865600000 - 75600000], ["慶雲", -39936369600000 - 75600000], ["和銅", -39821371200000 - 75600000], ["霊亀", -39579883200000 - 75600000], ["養老", -39509640000000 - 75600000], ["神亀", -39314289600000 - 75600000], ["天平", -39140712000000 - 75600000], ["天平感宝", -38520014400000 - 75600000], ["天平勝宝", -38510769600000 - 75600000], ["天平宝字", -38256753600000 - 75600000], ["天平神護", -38023041600000 - 75600000], ["神護景雲", -37940616000000 - 75600000], ["宝亀", -37842465600000 - 75600000], ["天応", -37518292800000 - 75600000], ["延暦", -37465761600000 - 75600000], ["大同", -36718228800000 - 75600000], ["弘仁", -36580420800000 - 75600000], ["天長", -36160603200000 - 75600000], ["承和", -35844465600000 - 75600000], ["嘉祥", -35389483200000 - 75600000], ["仁寿", -35298763200000 - 75600000], ["斉衡", -35186356800000 - 75600000], ["天安", -35115681600000 - 75600000], ["貞観", -35047339200000 - 75600000], ["元慶", -34478222400000 - 75600000], ["仁和", -34232846400000 - 75600000], ["寛平", -34099704000000 - 75600000], ["昌泰", -33816571200000 - 75600000], ["延喜", -33712977600000 - 75600000], ["延長", -33026875200000 - 75600000], ["承平", -32775537600000 - 75600000], ["天慶", -32551416000000 - 75600000], ["天暦", -32270702400000 - 75600000], ["天徳", -31938667200000 - 75600000], ["応和", -31834987200000 - 75600000], ["康保", -31725864000000 - 75600000], ["安和", -31597905600000 - 75600000], ["天禄", -31545892800000 - 75600000], ["天延", -31428907200000 - 75600000], ["貞元", -31347864000000 - 75600000], ["天元", -31272523200000 - 75600000], ["永観", -31133419200000 - 75600000], ["寛和", -31071124800000 - 75600000], ["永延", -31009262400000 - 75600000], ["永祚", -30935044800000 - 75600000], ["正暦", -30896856000000 - 75600000], ["長徳", -30760344000000 - 75600000], ["長保", -30638606400000 - 75600000], ["寛弘", -30464510400000 - 75600000], ["長和", -30196152000000 - 75600000], ["寛仁", -30061108800000 - 75600000], ["治安", -29940494400000 - 75600000], ["万寿", -29832408000000 - 75600000], ["長元", -29706264000000 - 75600000], ["長暦", -29430993600000 - 75600000], ["長久", -29317204800000 - 75600000], ["寛徳", -29190974400000 - 75600000], ["永承", -29145873600000 - 75600000], ["天喜", -28934366400000 - 75600000], ["康平", -28756814400000 - 75600000], ["治暦", -28537185600000 - 75600000], ["延久", -28421409600000 - 75600000], ["承保", -28252152000000 - 75600000], ["承暦", -28150545600000 - 75600000], ["永保", -28046606400000 - 75600000], ["応徳", -27952516800000 - 75600000], ["寛治", -27852984000000 - 75600000], ["嘉保", -27609854400000 - 75600000], ["永長", -27548424000000 - 75600000], ["承徳", -27517492800000 - 75600000], ["康和", -27463320000000 - 75600000], ["長治", -27321969600000 - 75600000], ["嘉承", -27253195200000 - 75600000], ["天仁", -27179755200000 - 75600000], ["天永", -27120139200000 - 75600000], ["永久", -27023284800000 - 75600000], ["元永", -26876059200000 - 75600000], ["保安", -26811691200000 - 75600000], ["天治", -26684683200000 - 75600000], ["大治", -26629560000000 - 75600000], ["天承", -26470670400000 - 75600000], ["長承", -26421336000000 - 75600000], ["保延", -26335627200000 - 75600000], ["永治", -26140708800000 - 75600000], ["康治", -26116084800000 - 75600000], ["天養", -26057937600000 - 75600000], ["久安", -26014564800000 - 75600000], ["仁平", -25840728000000 - 75600000], ["久寿", -25720718400000 - 75600000], ["保元", -25674840000000 - 75600000], ["平治", -25581009600000 - 75600000], ["永暦", -25556385600000 - 75600000], ["応保", -25505928000000 - 75600000], ["長寛", -25455211200000 - 75600000], ["永万", -25385918400000 - 75600000], ["仁安", -25348248000000 - 75600000], ["嘉応", -25265649600000 - 75600000], ["承安", -25200763200000 - 75600000], ["安元", -25067534400000 - 75600000], ["治承", -25003252800000 - 75600000], ["養和", -24877368000000 - 75600000], ["寿永", -24850756800000 - 75600000], ["元暦", -24790449600000 - 75600000], ["文治", -24749841600000 - 75600000], ["建久", -24602097600000 - 75600000], ["正治", -24317496000000 - 75600000], ["建仁", -24259953600000 - 75600000], ["元久", -24164913600000 - 75600000], ["建永", -24095448000000 - 75600000], ["承元", -24049742400000 - 75600000], ["建暦", -23941396800000 - 75600000], ["建保", -23854910400000 - 75600000], ["承久", -23685998400000 - 75600000], ["貞応", -23591476800000 - 75600000], ["元仁", -23509310400000 - 75600000], ["嘉禄", -23496523200000 - 75600000], ["安貞", -23413147200000 - 75600000], ["寛喜", -23375304000000 - 75600000], ["貞永", -23278622400000 - 75600000], ["天福", -23244321600000 - 75600000], ["文暦", -23196715200000 - 75600000], ["嘉禎", -23167425600000 - 75600000], ["暦仁", -23067633600000 - 75600000], ["延応", -23061326400000 - 75600000], ["仁治", -23017176000000 - 75600000], ["寛元", -22934664000000 - 75600000], ["宝治", -22806878400000 - 75600000], ["建長", -22741387200000 - 75600000], ["康元", -22505342400000 - 75600000], ["正嘉", -22491691200000 - 75600000], ["正元", -22426891200000 - 75600000], ["文応", -22392331200000 - 75600000], ["弘長", -22366238400000 - 75600000], ["文永", -22271112000000 - 75600000], ["建治", -21919204800000 - 75600000], ["弘安", -21829694400000 - 75600000], ["正応", -21508286400000 - 75600000], ["永仁", -21341880000000 - 75600000], ["正安", -21161563200000 - 75600000], ["乾元", -21049675200000 - 75600000], ["嘉元", -21025483200000 - 75600000], ["徳治", -20920075200000 - 75600000], ["延慶", -20861841600000 - 75600000], ["応長", -20783563200000 - 75600000], ["正和", -20753668800000 - 75600000], ["文保", -20599531200000 - 75600000], ["元応", -20531016000000 - 75600000], ["元亨", -20472782400000 - 75600000], ["正中", -20354068800000 - 75600000], ["嘉暦", -20309227200000 - 75600000], ["元徳", -20204424000000 - 75600000], ["元弘", -20142302400000 - 75600000], ["正慶", -20120270400000 - 75600000], ["建武", -20064024000000 - 75600000], ["延元", -19997668800000 - 75600000], ["興国", -19867636800000 - 75600000], ["正平", -19657598400000 - 75600000], ["建徳", -18913780800000 - 75600000], ["文中", -18859867200000 - 75600000], ["天授", -18760420800000 - 75600000], ["弘和", -18580708800000 - 75600000], ["元中", -18479707200000 - 75600000], ["暦応", -19918785600000 - 75600000], ["康永", -19803960000000 - 75600000], ["貞和", -19694836800000 - 75600000], ["観応", -19556510400000 - 75600000], ["文和", -19474862400000 - 75600000], ["延文", -19364961600000 - 75600000], ["康安", -19206763200000 - 75600000], ["貞治", -19161403200000 - 75600000], ["応安", -18990849600000 - 75600000], ["永和", -18768110400000 - 75600000], ["康暦", -18640929600000 - 75600000], ["永徳", -18579499200000 - 75600000], ["至徳", -18484891200000 - 75600000], ["嘉慶", -18373003200000 - 75600000], ["康応", -18328161600000 - 75600000], ["明徳", -18293515200000 - 75600000], ["応永", -18157608000000 - 75600000], ["正長", -17089185600000 - 75600000], ["永享", -17047713600000 - 75600000], ["嘉吉", -16686907200000 - 75600000], ["文安", -16593595200000 - 75600000], ["宝徳", -16420708800000 - 75600000], ["享徳", -16326532800000 - 75600000], ["康正", -16229592000000 - 75600000], ["長禄", -16162977600000 - 75600000], ["寛正", -16058952000000 - 75600000], ["文正", -15897643200000 - 75600000], ["応仁", -15863860800000 - 75600000], ["文明", -15795518400000 - 75600000], ["長享", -15222168000000 - 75600000], ["延徳", -15155726400000 - 75600000], ["明応", -15064056000000 - 75600000], ["文亀", -14792760000000 - 75600000], ["永正", -14698238400000 - 75600000], ["大永", -14145278400000 - 75600000], ["享禄", -13926081600000 - 75600000], ["天文", -13800283200000 - 75600000], ["弘治", -13068475200000 - 75600000], ["永禄", -12993998400000 - 75600000], ["元亀", -12609259200000 - 75600000], ["天正", -12506788800000 - 75600000], ["文禄", -11896113600000 - 75600000], ["慶長", -11772043200000 - 75600000], ["元和", -11181326400000 - 75600000], ["寛永", -10909425600000 - 75600000], ["正保", -10254859200000 - 75600000], ["慶安", -10152907200000 - 75600000], ["承応", -10009742400000 - 75600000], ["明暦", -9928526400000 - 75600000], ["万治", -9825624000000 - 75600000], ["寛文", -9738705600000 - 75600000], ["延宝", -9346190400000 - 75600000], ["天和", -9092865600000 - 75600000], ["貞享", -9017006400000 - 75600000], ["元禄", -8873409600000 - 75600000], ["宝永", -8384990400000 - 75600000], ["正徳", -8159313600000 - 75600000], ["享保", -7996363200000 - 75600000], ["元文", -7370654400000 - 75600000], ["寛保", -7217726400000 - 75600000], ["延享", -7123809600000 - 75600000], ["寛延", -6986865600000 - 75600000], ["宝暦", -6880939200000 - 75600000], ["明和", -6485054400000 - 75600000], ["安永", -6218510400000 - 75600000], ["天明", -5954299200000 - 75600000], ["寛政", -5707454400000 - 75600000], ["享和", -5326430400000 - 75600000], ["文化", -5231476800000 - 75600000], ["文政", -4784097600000 - 75600000], ["天保", -4384497600000 - 75600000], ["弘化", -3943857600000 - 75600000], ["嘉永", -3842078400000 - 75600000], ["安政", -3627806400000 - 75600000], ["万延", -3462782400000 - 75600000], ["文久", -3432110400000 - 75600000], ["元治", -3337588800000 - 75600000], ["慶応", -3303028800000 - 75600000], ["明治", -3216715200000 - 75600000], ["大正", -1812110400000 - 75600000], ["昭和", -1357560000000 - 75600000], ["平成", 600264000000 - 75600000], ["令和", 1556712000000 - 75600000]];
GREGORIO = {
  calendar: ["1970年1月1日(木)0時0分0秒", 0, [4, 100, 400]],
  yeary: [['日', '月', '火', '水', '木', '金', '土'], [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12].map(function (i) {
    return `${i}月`;
  }), [31, 0, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]],
  //   節    中     節    中     節    中 
  seasonly: [["立春", "雨水", "啓蟄", "春分", "清明", "穀雨", "立夏", "小満", "芒種", "夏至", "小暑", "大暑", "立秋", "処暑", "白露", "秋分", "寒露", "霜降", "立冬", "小雪", "大雪", "冬至", "小寒", "大寒"]],
  moony: [['朔', '既朔', '三日月', '上弦', '上弦', '上弦', '上弦', '上弦', '上弦', '上弦', '上弦', '上弦', '十三夜', '小望月', '満月', '十六夜', '立待月', '居待月', '臥待月', '更待月', '下限', '下限', '下限', '下限', '下限', '下限', '下限', '下限', '晦', '晦']],
  daily: [function () {
    var results = [];

    for (var j = 0; j < 24; j++) {
      results.push(j);
    }

    return results;
  }.apply(undefined).map(function (i) {
    return `${i}時`;
  }), function () {
    var results = [];

    for (var j = 0; j < 60; j++) {
      results.push(j);
    }

    return results;
  }.apply(undefined).map(function (i) {
    return `${i}分`;
  })]
};
平気法 = {
  calendar: ["1970年1月1日(木)0時0分0秒", 0],
  yeary: [["先勝", "友引", "先負", "仏滅", "大安", "赤口"], ['睦月', '如月', '弥生', '卯月', '皐月', '水無月', '文月', '葉月', '長月', '神無月', '霜月', '師走']],
  daily: [['夜九つ', '夜八つ', '暁七つ', '明六つ', '朝五つ', '昼四つ', '昼九つ', '昼八つ', '夕七つ', '暮六つ', '宵五つ', '夜四つ'], ['一つ', '二つ', '三つ', '四つ']]
};
FancyDate.Gregorian = g = new FancyDate().planet(...EARTH).calendar(...GREGORIO.calendar).era("西暦").yeary(...GREGORIO.yeary).seasonly(...GREGORIO.seasonly).moony(...GREGORIO.moony).daily(...GREGORIO.daily).init();
FancyDate.平気法 = new FancyDate().planet(...EARTH).calendar(...平気法.calendar).era("謎暦", ERAS).yeary(...平気法.yeary).seasonly(...GREGORIO.seasonly).moony(...GREGORIO.moony).daily(...平気法.daily).init();
FancyDate.Fast = new FancyDate().planet(...FastEarth).calendar(...GREGORIO.calendar).era("fast", ERAS).yeary(...GREGORIO.yeary).seasonly(...GREGORIO.seasonly).moony(...GREGORIO.moony).daily(...GREGORIO.daily).init();
FancyDate.Mars = g.dup().planet(...MARS).calendar(...GREGORIO.calendar).init();

/***/ }),

/***/ "./src/fancy-date.coffee":
/*!*******************************!*\
  !*** ./src/fancy-date.coffee ***!
  \*******************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.FancyDate = void 0;

var _,
    by_tempo,
    calc_set,
    daily_define,
    daily_measure,
    default_format_format,
    default_parse_format,
    reg_parse,
    reg_token,
    sub_define,
    timezone,
    to_msec,
    to_sec,
    to_tempo_bare,
    to_tempo_by,
    to_timer,
    splice = [].splice,
    slice = [].slice,
    modulo = function (a, b) {
  return (+a % (b = +b) + b) % b;
};

({
  timezone,
  by_tempo,
  to_timer,
  to_msec,
  to_sec,
  to_tempo_by,
  to_tempo_bare
} = __webpack_require__(/*! ./time */ "./src/time.coffee"));
_ = __webpack_require__(/*! lodash */ "lodash");
reg_parse = /(\d+)年(\d+)月(\d+)日\(([^)])\)(\d+)時(\d+)分(\d+)秒/;
reg_token = /[yYQqMLwIdDecihHKkms]o|(\w)\1*|''|'(''|[^'])+('|$)|./g;
default_parse_format = "yyyyMMdd";
default_format_format = "GyMd(e)Hms";

calc_set = function (path, o) {
  var key, results, val;
  results = [];

  for (key in o) {
    val = o[key];
    results.push(this.calc[path][key] = (val != null ? val[path] : void 0) || val);
  }

  return results;
};

sub_define = function (msec, size) {
  var range;
  range = [size];
  msec = msec / size;
  return {
    range,
    msec
  };
};

daily_define = function (msec, day) {
  var range;
  range = [Math.floor(msec / day)];
  msec = range[0] * day;
  return {
    range,
    msec
  };
};

daily_measure = function (msec, day) {
  var range;
  range = [Math.floor(msec / day), Math.ceil(msec / day)];
  return {
    range,
    msec
  };
};

var FancyDate = class FancyDate {
  constructor(o) {
    var calc, dic;

    if (o) {
      ({
        dic,
        calc
      } = o);
      this.dic = _.cloneDeep(dic);
      this.calc = _.cloneDeep(calc);
    } else {
      this.dic = {};
      this.calc = {
        eras: [],
        divs: {},
        idx: {},
        gap: {},
        zero: {},
        msec: {},
        range: {}
      };
    }
  }

  dup() {
    return new this.constructor(this);
  }

  planet([revolution = g.calc.msec.year, spring = g.dic.spring], [synodic = g.calc.msec.moon, synodic_zero = g.dic.synodic_zero], [rotation = g.calc.msec.day, rotation_zero = g.dic.rotation_zero], axtial_tilt = g.dic.axtial_tilt, geo = g.dic.geo) {
    var day, lat, lng, moon, tz_offset, year;
    year = daily_measure(revolution, rotation);
    moon = daily_measure(synodic, rotation);
    day = daily_define(rotation, rotation);
    calc_set.call(this, "range", {
      year,
      moon,
      day
    });
    calc_set.call(this, "msec", {
      year,
      moon,
      day
    });
    [lat, lng] = geo;
    tz_offset = rotation / 360 * lng;
    Object.assign(this.dic, {
      geo,
      lat,
      lng,
      axtial_tilt,
      spring,
      synodic_zero,
      rotation_zero,
      tz_offset
    });
    return this;
  }

  era(era, eras = []) {
    eras = _.cloneDeep(eras);
    Object.assign(this.dic, {
      era,
      eras
    });
    return this;
  }

  yeary(weeks = g.dic.weeks, months = g.dic.months, month_ranges) {
    var month, week;
    month = daily_measure(this.calc.msec.year / months.length, this.calc.msec.day);
    week = daily_define(weeks.length * this.calc.msec.day, this.calc.msec.day);
    calc_set.call(this, "range", {
      month,
      week
    });
    calc_set.call(this, "msec", {
      month,
      week
    });
    Object.assign(this.dic, {
      weeks,
      months,
      month_ranges
    });
    return this;
  }

  moony(moons) {
    Object.assign(this.dic, {
      moons
    });
    return this;
  }

  seasonly(seasons) {
    var season;
    season = sub_define(this.calc.msec.year, seasons.length);
    calc_set.call(this, "range", {
      season
    });
    calc_set.call(this, "msec", {
      season
    });
    Object.assign(this.dic, {
      seasons
    });
    return this;
  }

  daily(hours = g.dic.hours, minutes = g.dic.minutes) {
    var hour, minute, second;
    hour = sub_define(this.calc.msec.day, hours.length);
    minute = sub_define(hour.msec, minutes.length);
    second = sub_define(minute.msec, minute.msec / 1000);
    calc_set.call(this, "range", {
      hour,
      minute,
      second
    });
    calc_set.call(this, "msec", {
      hour,
      minute,
      second
    });
    Object.assign(this.dic, {
      hours,
      minutes
    });
    return this;
  }

  calendar(start = g.dic.start, start_at = g.dic.start_at, leaps = null) {
    Object.assign(this.dic, {
      leaps,
      start,
      start_at
    });
    return this;
  }

  init() {
    var a, idx, list, msec, title, u, zero;
    this.def_table();
    calc_set.call(this, "idx", this.def_idx());
    calc_set.call(this, "zero", this.def_zero());
    zero = this.calc.zero.era;

    list = function () {
      var j, len, ref, results;
      ref = this.dic.eras;
      results = [];

      for (idx = j = 0, len = ref.length; j < len; idx = ++j) {
        [title, msec] = ref[idx];
        ({
          u
        } = this.to_tempos(msec));
        a = [title, msec, u.now_idx];
        this.calc.eras.push(a);
        results.push(msec - zero);
      }

      return results;
    }.call(this);

    list.push(2e308);
    this.table.msec.era = list;
    return this;
  }

  def_table_by_leap_year() {
    var a, day, div, i, idx, is_leap, j, k, l, leaps, len, len1, len2, mode, month, month_ranges, month_sum, months, period, range, ref, size, str, upto, year, years;
    day = this.calc.msec.day;

    upto = function (src) {
      var i, j, len, msec, results;
      msec = 0;
      results = [];

      for (j = 0, len = src.length; j < len; j++) {
        i = src[j];
        results.push(msec += i * day);
      }

      return results;
    };

    ref = this.dic.leaps, [...leaps] = ref, [period] = splice.call(leaps, -1);
    range = {
      year: function () {
        var j, k, len, ref1, results;
        results = [];

        for (idx = j = 0, ref1 = period; 0 <= ref1 ? j < ref1 : j > ref1; idx = 0 <= ref1 ? ++j : --j) {
          is_leap = 0;

          for (mode = k = 0, len = leaps.length; k < len; mode = ++k) {
            div = leaps[mode];

            if (idx % div) {
              continue;
            }

            is_leap = !mode % 2;
          }

          results.push(this.calc.range.year[is_leap]);
        }

        return results;
      }.call(this)
    };
    range.year[0] = this.calc.range.year[1];
    years = _.uniq(range.year);
    ({
      month_ranges,
      months
    } = this.dic);

    if (!month_ranges) {
      month_ranges = function () {
        var j, len, results;
        results = [];

        for (idx = j = 0, len = months.length; j < len; idx = ++j) {
          str = months[idx];
          results.push(this.calc.range.month[1 - idx % 2]);
        }

        return results;
      }.call(this);

      month_ranges[1] = 0;
    }

    month_sum = 0;

    for (j = 0, len = month_ranges.length; j < len; j++) {
      i = month_ranges[j];
      month_sum += i;
    }

    range.month = {};

    for (k = 0, len1 = years.length; k < len1; k++) {
      size = years[k];
      a = Array.from(month_ranges);
      a[1] = size - month_sum;
      range.month[size] = a;
    }

    year = upto(range.year);
    period = year[year.length - 1];
    period = daily_define(period, day);
    calc_set.call(this, "msec", {
      period
    });
    month = {};

    for (l = 0, len2 = years.length; l < len2; l++) {
      size = years[l];
      month[size * day] = upto(range.month[size]);
    }

    this.table = {
      range,
      msec: {
        year,
        month
      }
    };
    return function ({
      size
    }, path) {
      switch (path) {
        case 'year':
          return year;

        case 'month':
          return month[size];

        default:
          return null;
      }
    };
  }

  def_table_by_season() {
    this.table = {
      range: {},
      msec: {}
    };
    return function (o, path) {
      return null;
    };
  }

  def_table() {
    return this.get_table = this.dic.leaps != null ? this.def_table_by_leap_year() : this.def_table_by_season();
  }

  def_idx() {
    var day, full_period, hour, minute, month, moon, period, ref, season, second, week, year;
    week = this.dic.weeks.length;
    calc_set.call(this, "divs", {
      week
    });
    [, year, month, day, week, hour, minute, second] = this.dic.start.match(reg_parse);
    year = year - 0;
    month = month - 0;
    day = day - 0;
    hour = hour - 0;
    minute = minute - 0;
    second = second - 0;
    week = this.dic.weeks.indexOf(week);
    season = this.dic.seasons.indexOf('春分');
    moon = 0;

    if (this.dic.leaps != null) {
      ref = this.dic.leaps, [full_period] = slice.call(ref, -1);
      period = full_period;
      calc_set.call(this, "divs", {
        period
      });
      period = Math.floor(year / this.calc.divs.period);
      year = year % this.calc.divs.period;
      return {
        period,
        year,
        month,
        moon,
        week,
        day,
        hour,
        minute,
        second,
        season
      };
    } else {
      return {
        year,
        month,
        moon,
        week,
        day,
        hour,
        minute,
        second,
        season
      };
    }
  }

  def_zero() {
    var day, era, hour, jd, ld, minute, mjd, month, moon, period, ref, season, second, since, week, year, year_size, zero, zero_size;

    zero_size = (path, idx = 0) => {
      return this.dic.start_at - (this.calc.idx[path] - idx) * this.calc.msec[path];
    };

    zero = this.dic.start_at - this.dic.start_at - this.dic.tz_offset;
    second = zero + zero_size("second");
    minute = second + zero_size("minute");
    hour = minute + zero_size("hour");
    day = hour + zero_size("day", 1);
    week = day + zero_size("week") / this.calc.divs.week; // 元号

    era = ((ref = this.dic.eras[0]) != null ? ref[1] : void 0) || 2e308;
    this.calc.eras = []; // JD

    jd = -2440587.5 * this.calc.msec.day;
    ld = jd + 2299159.5 * this.calc.msec.day;
    mjd = jd + 2400000.5 * this.calc.msec.day; // 単純のため平気法。

    season = this.dic.spring + zero_size("season"); // 立春点

    ({
      since
    } = to_tempo_bare(this.calc.msec.year, this.dic.start_at, season));
    season = since + zero_size("year");
    moon = 0 - this.dic.synodic_zero;

    if (this.dic.leaps != null) {
      year_size = this.calc.msec.day * this.table.range.year[modulo(this.calc.idx.year, this.calc.divs.period)];
      month = day - (this.table.msec.month[year_size][this.calc.idx.month - 2] || 0);
      year = month - (this.table.msec.year[this.calc.idx.year - 1] || 0);
      period = year + zero_size("period");
      season += zero_size("period");

      if (period < era) {
        era = period + this.table.msec.year[0];
        this.calc.eras = [[this.dic.era, era, 1]];
      }
    } else {
      if (season < era) {
        era = season + this.calc.msec.year;
        this.calc.eras = [[this.dic.era, era, 1]];
      }
    }

    return {
      period,
      era,
      week,
      season,
      moon,
      day,
      jd,
      ld,
      mjd
    };
  }
  /*
  http://bakamoto.sakura.ne.jp/buturi/2hinode.pdf
  ベクトルで
  a1 = e1 * cos(lat/360) + e3 * sin(lat/360)
  a2 = e3 * cos(lat/360) - e1 * sin(lat/360)
  T = (赤緯, 時角)->
    a1 * sin(赤緯) + cos(赤緯) * (a2 * cos(時角) - e2 * sin(時角))
  T = ( lat, 赤緯, 時角 )->
    e1 * ( cos(lat/360) * sin(赤緯) - sin(lat/360) * cos(赤緯) * cos(時角) ) +
    e2 * (-cos(赤緯) * sin(時角)) +
    e3 * ( sin(lat/360) * sin(赤緯) + cos(lat/360) * cos(赤緯) * cos(時角) )
   K   = g.dic.axtial_tilt / 360
  高度 = -50/60
  時角 = ( lat, 高度, 赤緯 )->
    acos(( sin(高度) - sin(lat/360) * sin(赤緯) ) / cos(lat/360) * cos(赤緯) )
  方向角 = ( lat, 高度, 赤緯, 時角 )->
    acos(( cos(lat/360) * sin(赤緯) - sin(lat/360) * cos(赤緯) * cos(時角) ) / cos(高度) )
  季節 = 春分点からの移動角度
  赤緯 = asin( sin(K) * sin(季節) )
  赤経 = atan( tan(季節) * cos(K) )
  南中時刻 = ->
    正午 + 時角 + ( 赤経 - 季節 ) + 平均値 + tz_offset
  日の出 = ->
    南中時刻 - 時角
  日の入 = ->
    南中時刻 + 時角
  */


  solor(utc, idx = 2) {
    var K, PI, T0, T1, acos, asin, atan, cos, day, days, deg_to_rad, graph, lat, rad_to_day, sin, spring, tan, year_to_rad, 南中差分A, 南中差分B, 南中時刻, 季節, 方向角, 日の入, 日の出, 時角, 赤経, 赤緯, 高度;
    days = [6, // golden hour end         / golden hour
    -18 / 60, // sunrise bottom edge end / sunset bottom edge start
    -50 / 60, // sunrise top edge start  / sunset top edge end
    -6, // dawn                    / dusk
    -12, // nautical dawn           / nautical dusk
    -18 // night end               / night
    ];
    ({
      asin,
      acos,
      atan,
      sin,
      cos,
      tan,
      PI
    } = Math);
    deg_to_rad = 2 * PI / 360;
    year_to_rad = 2 * PI / this.calc.msec.year;
    rad_to_day = this.calc.msec.day / (2 * PI);
    高度 = days[idx] * deg_to_rad;
    K = this.dic.axtial_tilt * deg_to_rad;
    lat = this.dic.lat * deg_to_rad;
    T0 = to_tempo_bare(this.calc.msec.year, this.calc.zero.season, utc);
    day = to_tempo_bare(this.calc.msec.day, -this.dic.tz_offset, utc); // 南中差分の計算がテキトウになってしまった。あとで検討。

    南中差分A = 2 * this.calc.msec.day / 360 * sin(T0.since * year_to_rad);
    南中差分B = 2.5 * this.calc.msec.day / 360 * sin((T0.since + 1296000000) * year_to_rad * 2);
    南中時刻 = (day.last_at + day.next_at) / 2 + 南中差分A + 南中差分B;
    T1 = to_tempo_bare(this.calc.msec.year, this.dic.spring, 南中時刻);
    spring = T1.last_at;
    季節 = T1.since * year_to_rad;
    赤緯 = asin(sin(K) * sin(季節));
    赤経 = atan(tan(季節) * cos(K));
    時角 = acos((sin(高度) - sin(lat) * sin(赤緯)) / cos(lat) * cos(赤緯));
    方向角 = acos((cos(lat) * sin(赤緯) - sin(lat) * cos(赤緯) * cos(時角)) / cos(高度));
    日の出 = 南中時刻 - 時角 * rad_to_day;
    日の入 = 南中時刻 + 時角 * rad_to_day;
    graph = `  赤緯.${Math.floor(赤緯 / deg_to_rad)}  赤経.${Math.floor(赤経 / deg_to_rad)}  方向角.${Math.floor(方向角 / deg_to_rad)}  時角.${Math.floor(時角 / deg_to_rad)}  日の出.${this.format(日の出, 'Hm')}  南中時刻.${this.format(南中時刻, 'Hm')}  日の入.${this.format(日の入, 'Hm')}`;
    return {
      時角,
      方向角,
      南中時刻,
      日の出,
      日の入,
      graph
    };
  }

  to_tempos(utc) {
    var D, E, G, H, J, M, N, N0, N0_p, Nn, Nn_p, Np, Np_p, S, Z, Zz, after_leap_month, d, drill_down, e, era, era_base, graph, m, now_idx, p, s, to_tempo_mod, u, w, y;

    drill_down = (base, path, at = utc) => {
      var b_size, o, table;
      table = this.get_table(base, path);

      if (table) {
        o = to_tempo_by(table, base.last_at, at);
      } else {
        b_size = this.calc.msec[path];
        o = to_tempo_bare(b_size, base.last_at, at);
        o.length = base.size / o.size;
      }

      o.path = path;
      return o;
    };

    to_tempo_mod = (path, sub, at = utc) => {
      var do1, do2, do3, o;
      o = to_tempo_bare(this.calc.msec[path], this.calc.zero[path], at);
      do2 = to_tempo_bare(this.calc.msec[sub], this.calc.zero[sub], o.next_at);

      if (do2.last_at <= at) {
        do3 = to_tempo_bare(this.calc.msec[sub], this.calc.zero[sub], o.next_at + o.size);
        o.now_idx += 1;
        o.last_at = do2.last_at;
        o.next_at = do3.last_at;
      } else {
        do1 = to_tempo_bare(this.calc.msec[sub], this.calc.zero[sub], o.next_at - o.size);
        o.last_at = do1.last_at;
        o.next_at = do2.last_at;
      }

      return o;
    };

    J = to_tempo_bare(this.calc.msec.day, this.calc.zero.jd, utc); // ユリウス日
    // season in year_of_planet

    Zz = to_tempo_bare(this.calc.msec.year, this.calc.zero.season, utc); // 太陽年
    // 正月中気

    N0_p = Zz.last_at + this.calc.msec.season;
    N0 = to_tempo_mod("moon", "day", N0_p); // 今月と中気

    Nn = to_tempo_mod("moon", "day", utc);
    Nn.now_idx -= N0.now_idx;
    Nn_p = Zz.last_at + this.calc.msec.season * (1 + Nn.now_idx * 2); // 先月と中気

    Np = to_tempo_mod("moon", "day", Nn.last_at - 1);
    Np.now_idx -= N0.now_idx;
    Np_p = Zz.last_at + this.calc.msec.season * (1 + Np.now_idx * 2);

    if (!(after_leap_month = Np.next_at <= Np_p)) {
      Nn.is_leap = Nn.next_at <= Nn_p;
    }

    if (after_leap_month) {
      Nn.now_idx -= 1;
    } else {
      switch (Nn.now_idx) {
        case -1:
          // 太陽年初に0月が出てしまう。昨年末にする。
          Nn.now_idx = this.dic.months.length - 1;
          Zz.now_idx -= 1;
          break;

        case this.dic.months.length:
          // 太陽年末に13月が出てしまう。年初にする。
          Nn.now_idx = 0;
          Zz.now_idx += 1;
      }
    }

    Z = drill_down(Zz, "season"); // 太陽年の二十四節気

    N = drill_down(Nn, 'day'); // day    in week (曜日)

    w = to_tempo_bare(this.calc.msec.week, this.calc.zero.week, utc);
    e = E = drill_down(w, "day");

    if (this.dic.leaps != null) {
      p = to_tempo_bare(this.calc.msec.period, this.calc.zero.period, utc);
      u = drill_down(p, "year");
      u.now_idx = u.now_idx + p.now_idx * this.calc.divs.period;
      M = drill_down(u, "month");
      d = drill_down(M, "day");
    } else {
      u = Zz;
      M = Nn;
      d = N; // 旧暦では、週は月初にリセットする。

      e.now_idx = (M.now_idx + d.now_idx) % this.dic.weeks.length;
    } //        in year appendix


    D = drill_down(u, "day"); // hour   in day

    H = drill_down(d, "hour"); // minute in day

    m = drill_down(H, "minute");
    s = drill_down(m, "second");
    now_idx = utc - s.last_at;
    S = {
      now_idx
    };
    G = {};

    if (this.table.msec.era != null) {
      era_base = to_tempo_by(this.table.msec.era, this.calc.zero.era, utc);
      era = this.calc.eras[era_base.now_idx];

      if (era != null ? era[0] : void 0) {
        u.now_idx += 1 - era[2];
        G.label = era[0];
      }
    }

    y = Object.assign({}, u);

    if (u.now_idx < 1) {
      G.label = "紀元前";
      y.now_idx = 1 - u.now_idx;
    }

    graph = `${this.dic.seasons[Z.now_idx]} ${Z.now_idx % 2 ? _.padStart((Z.now_idx + 1) / 2, 2, '0') : "  "}\t ${y.now_idx}年${Nn.is_leap ? "閏" : "  "}${_.padStart(Nn.now_idx + 1, 2, '0')}月${_.padStart(N.now_idx + 1, 2, '0')}日\t`;
    return {
      G,
      u,
      y,
      M,
      d,
      D,
      w,
      e,
      E,
      H,
      m,
      s,
      S,
      Z,
      N,
      J,
      era,
      graph
    };
  }

  index(tgt, str = default_parse_format) {
    var H, J, M, S, d, data, idx, j, len, m, p, ref, reg, s, token, tokens, val, y;
    tokens = str.match(reg_token);
    reg = this.parse_reg();
    reg = "^" + tokens.map(function (token) {
      var val;

      if (val = reg[token[0]]) {
        return val;
      } else {
        return token.replace(/([\\\[\]().*?])/g, "\\$1");
      }
    }).join("");
    idx = this.parse_idx();
    p = y = M = d = H = m = s = S = J = 0;
    data = {
      p,
      y,
      M,
      d,
      H,
      m,
      s,
      S,
      J
    };
    ref = tgt.match(reg).slice(1);

    for (p = j = 0, len = ref.length; j < len; p = ++j) {
      s = ref[p];
      token = tokens[p];

      if (val = idx[token[0]]) {
        data[token[0]] = val(s);
      }
    }

    if (this.dic.leaps != null) {
      data.p = Math.floor(data.y / this.calc.divs.period);
      data.y = data.y - data.p * this.calc.divs.period;
    }

    return data;
  }

  parse_reg() {
    var G, H, J, M, S, d, join, m, s, y;

    join = function (list) {
      return `(${list.join("|")})`;
    };

    G = join([this.dic.era, "紀元前"]);
    y = "((?:\\d)+年)";
    M = join(this.dic.months);
    d = "((?:\\d)+日)";
    H = join(this.dic.hours);
    m = join(this.dic.minutes);
    s = "((?:\\d)+秒)";
    S = "(\\d+)";
    J = "([\\d.]+)";
    return {
      G,
      y,
      M,
      d,
      H,
      m,
      s,
      S,
      J
    };
  }

  parse_idx() {
    var G, H, J, M, S, d, m, s, y;

    G = s => {
      return this.dic.era.indexOf(s);
    };

    y = s => {
      return s.slice(0, -1) - 0;
    };

    M = s => {
      return this.dic.months.indexOf(s);
    };

    d = s => {
      return s.slice(0, -1) - 1;
    };

    H = s => {
      return this.dic.hours.indexOf(s);
    };

    m = s => {
      return this.dic.minutes.indexOf(s);
    };

    s = s => {
      return s.slice(0, -1) - 0;
    };

    S = s => {
      return s.slice(0, -1) - 0;
    };

    J = s => {
      return s - 0;
    };

    return {
      G,
      y,
      M,
      d,
      H,
      m,
      s,
      S,
      J
    };
  }

  to_label(o, token, length) {
    switch (token) {
      case 'G':
        return o.label;

      case 'M':
        return `${o.is_leap ? "閏" : ""}${this.dic.months[o.now_idx]}`;

      case 'H':
        return this.dic.hours[o.now_idx];

      case 'm':
        return this.dic.minutes[o.now_idx];

      case 'e':
      case 'E':
        return this.dic.weeks[o.now_idx];

      case 'Z':
        return this.dic.seasons[o.now_idx];

      case 'N':
        return this.dic.moons[o.now_idx];

      case 'J':
        return `${_.padStart(o.now_idx, length, '0')}`;

      case 'y':
      case 'u':
        return `${_.padStart(o.now_idx, length, '0')}年`;

      case 'd':
        return `${_.padStart(o.now_idx + 1, length, '0')}日`;

      case 's':
        return `${_.padStart(o.now_idx, length, '0')}秒`;

      case 'S':
        return `${o.now_idx / this.calc.msec.second}`.slice(2);
    }
  }

  tempo_list(tempos, token) {
    var base, gap, j, k, last_at, len, length, list, next_at, now_idx, ref, size, table, tempo;

    switch (token[0]) {
      case 'G':
        throw new Error(`request token can't tempos. [${token}]`);
    }

    if (!(tempo = tempos[token[0]])) {
      throw new Error(`request token can't tempos. [${token}]`);
    }

    ({
      table,
      length,
      now_idx,
      last_at,
      size,
      gap
    } = tempo);
    list = [];

    if (table) {
      last_at = gap;

      for (now_idx = j = 0, len = table.length; j < len; now_idx = ++j) {
        next_at = table[now_idx];
        next_at += gap;
        size = next_at - last_at;
        list.push({
          now_idx,
          size,
          last_at,
          next_at,
          last_time: new Date(last_at),
          next_time: new Date(next_at)
        });
        last_at = next_at;
      }
    }

    if (length) {
      base = last_at - size * now_idx;

      for (now_idx = k = 0, ref = length; 0 <= ref ? k < ref : k > ref; now_idx = 0 <= ref ? ++k : --k) {
        last_at = (now_idx + 0) * size + gap;
        next_at = (now_idx + 1) * size + gap;
        list.push({
          now_idx,
          size,
          last_at,
          next_at,
          last_time: new Date(last_at),
          next_time: new Date(next_at)
        });
      }
    }

    return list;
  }

  ranges(utc, token) {
    return this.tempo_list(this.to_tempos(utc), token);
  }

  parse(tgt, str = default_parse_format) {
    var H, J, M, S, d, m, p, s, size, y;
    ({
      p,
      y,
      M,
      d,
      H,
      m,
      s,
      S,
      J
    } = this.index(tgt, str));

    if (J) {
      return this.calc.zero.jd + J * this.calc.msec.day;
    }

    return d * this.calc.msec.day + H * this.calc.msec.hour + m * this.calc.msec.minute + s * this.calc.msec.second + S + (this.dic.leaps != null ? (size = this.table.range.year[y] * this.calc.msec.day, this.calc.zero.period + p * this.calc.msec.period + (this.table.msec.year[y - 1] || 0) + (this.table.msec.month[size][M - 1] || 0)) : this.calc.zero.season + y * this.calc.msec.year + M * this.calc.msec.month);
  }

  format(utc, str = default_format_format) {
    var o;
    o = this.to_tempos(utc);
    return str.match(reg_token).map(token => {
      var val;

      if (val = o[token[0]]) {
        return this.to_label(val, token[0], token.length);
      } else {
        return token;
      }
    }).join("");
  }

};
exports.FancyDate = FancyDate;
module.exports = FancyDate;

/***/ }),

/***/ "./src/firebase.coffee":
/*!*****************************!*\
  !*** ./src/firebase.coffee ***!
  \*****************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var FirestoreQueryProxy, Mem, copy_to_str, firebase, firestore, firestore_base, joinSnapshot, m;
Mem = __webpack_require__(/*! memory-orm */ "memory-orm");

if (typeof window !== "undefined" && window !== null) {
  firebase = __webpack_require__(/*! firebase/app */ "firebase/app");

  __webpack_require__(/*! firebase/firestore */ "firebase/firestore");
}

firestore = function () {
  var store;
  store = firebase.firestore();
  store.settings({});
  return store;
};

copy_to_str = function (key) {
  return function (...args) {
    var arg, i, len;
    this.str += ` ${key}:`;

    for (i = 0, len = args.length; i < len; i++) {
      arg = args[i];
      this.str += arg;
      this.str += ":";
    }

    this.ref = this.ref[key](...args);
    return this;
  };
};

FirestoreQueryProxy = function () {
  class FirestoreQueryProxy {
    constructor(str, ref) {
      this.str = str;
      this.ref = ref;
    }

  }

  ;
  FirestoreQueryProxy.prototype.orderBy = copy_to_str("orderBy");
  FirestoreQueryProxy.prototype.limit = copy_to_str("limit");
  FirestoreQueryProxy.prototype.where = copy_to_str("where");
  return FirestoreQueryProxy;
}.call(undefined);

joinSnapshot = function (target, shot) {
  var eject;

  eject = function () {};

  return function (gate) {
    eject();
    return eject = gate && this[target] ? (console.log("join", gate), this[target].onSnapshot(shot.bind(this), function (err) {
      return console.error(err);
    })) : function () {};
  };
};

firestore_base = function (id, path, querys, {
  del,
  add,
  snap,
  shot
}) {
  var add_id, computed, default_id, del_id, join, join_id, joins, path_id, snap_id, watch;
  default_id = `${id}_default`;
  join_id = `${id}_join`;
  snap_id = `${id}_snap`;
  path_id = `${id}_path`;
  add_id = `${id}_add`;
  del_id = `${id}_del`;
  joins = [];
  watch = {};
  computed = {
    _firestore: firestore,
    [path_id]: path,
    [snap_id]: function () {
      if (this[path_id]) {
        return snap.call(this, this[path_id]);
      }
    }
  };

  if (querys != null ? querys.length : void 0) {
    querys.forEach(function (query, idx) {
      var join, query_id, ref_id, str_id;
      query_id = `${id}_query_${idx}_query`;
      ref_id = `${id}_query_${idx}_ref`;
      str_id = `${id}_query_${idx}_str`;

      computed[ref_id] = function () {
        if (!this[path_id]) {
          return;
        }

        return query.call(this, new FirestoreQueryProxy(this[path_id], this[snap_id]));
      };

      computed[str_id] = function () {
        var ref;
        return (ref = this[ref_id]) != null ? ref.str : void 0;
      };

      computed[query_id] = function () {
        if (this[str_id]) {
          return this[ref_id].ref;
        }
      };

      join = joinSnapshot(query_id, shot);
      joins.push([join, str_id]);
      return watch[str_id] = join;
    });
  } else {
    join = joinSnapshot(snap_id, shot);
    joins.push([join, path_id]);
    watch[path_id] = join;
  }

  return {
    beforeDestroy: function () {
      var i, len, results;
      results = [];

      for (i = 0, len = joins.length; i < len; i++) {
        [join, join_id] = joins[i];
        results.push(join.call(this, void 0));
      }

      return results;
    },
    mounted: function () {
      var i, len, results;
      this[default_id] = this[id];
      results = [];

      for (i = 0, len = joins.length; i < len; i++) {
        [join, join_id] = joins[i];
        results.push(join.call(this, this[join_id]));
      }

      return results;
    },
    methods: {
      [add_id]: add,
      [del_id]: del
    },
    computed: computed,
    watch: watch
  };
};

module.exports = m = {
  firestore_models: function (id, path, ...querys) {
    var set_key, snap_id;
    snap_id = `${id}_snap`;
    set_key = id.slice(0, -1);
    return firestore_base(id, path, querys, {
      del: function (_id) {
        var ref;

        if (!_id) {
          return;
        }

        return (ref = this[snap_id]) != null ? ref.doc(_id).delete() : void 0;
      },
      add: function (doc) {
        var _id, ref;

        ({
          _id
        } = doc);

        if (!_id) {
          return;
        }

        return (ref = this[snap_id]) != null ? ref.doc(_id).set(doc, {
          merge: true
        }) : void 0;
      },
      snap: function (path) {
        return this._firestore.collection(path);
      },
      shot: function (qs) {
        return qs.docChanges().forEach(({
          newIndex,
          oldIndex,
          type,
          doc
        }) => {
          switch (type) {
            case 'added':
            case 'modified':
              return Mem.Set[set_key].add(doc.data());

            case 'removed':
              return Mem.Set[set_key].remove(doc.id);
          }
        });
      }
    });
  },
  firestore_model: function (id, path) {
    var set_key, snap_id;
    snap_id = `${id}_snap`;
    set_key = id;
    return firestore_base(id, path, null, {
      del: function () {
        var ref;
        return (ref = this[snap_id]) != null ? ref.delete() : void 0;
      },
      add: function (doc) {
        var ref;
        return (ref = this[snap_id]) != null ? ref.set(doc, {
          merge: true
        }) : void 0;
      },
      snap: function (path) {
        return this._firestore.doc(path);
      },
      shot: function (doc) {
        var o;

        if (o = doc.data()) {
          return Mem.Set[set_key].add(o);
        } else {
          return Mem.Set[set_key].remove(doc.id);
        }
      }
    });
  },
  firestore_collection: function (id, path, ...querys) {
    var snap_id;
    snap_id = `${id}_snap`;
    return firestore_base(id, path, querys, {
      del: function (_id) {
        var ref;

        if (!_id) {
          return;
        }

        return (ref = this[snap_id]) != null ? ref.doc(_id).delete() : void 0;
      },
      add: function (doc) {
        var _id, ref;

        ({
          _id
        } = doc);

        if (!_id) {
          return;
        }

        return (ref = this[snap_id]) != null ? ref.doc(_id).set(doc, {
          merge: true
        }) : void 0;
      },
      snap: function (path) {
        return this._firestore.collection(path);
      },
      shot: function (qs) {
        return qs.docChanges().forEach(({
          newIndex,
          oldIndex,
          type,
          doc
        }) => {
          switch (type) {
            case 'added':
            case 'modified':
              return this[id][doc.id] = doc.data();

            case 'removed':
              return delete this[id][doc.id];
          }
        });
      }
    });
  },
  firestore_doc: function (id, path) {
    var default_id, snap_id;
    snap_id = `${id}_snap`;
    default_id = `${id}_default`;
    return firestore_base(id, path, null, {
      del: function () {
        var ref;
        return (ref = this[snap_id]) != null ? ref.delete() : void 0;
      },
      add: function (doc) {
        var ref;
        return (ref = this[snap_id]) != null ? ref.set(doc, {
          merge: true
        }) : void 0;
      },
      snap: function (path) {
        return this._firestore.doc(path);
      },
      shot: function (doc) {
        return this[id] = doc.exists ? doc.data() : this[default_id];
      }
    });
  }
};

/***/ }),

/***/ "./src/form.coffee":
/*!*************************!*\
  !*** ./src/form.coffee ***!
  \*************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var chk;

chk = function (all, local, msg, b) {
  all.push(msg);

  if (b) {
    return local.push(msg);
  }
};

module.exports = {
  error: function (id, cb) {
    var all_id, is_id, local_id;
    local_id = `${id}_local`;
    all_id = `${id}_all`;
    is_id = `is_${id}`;
    return {
      props: [id],
      data: function () {
        return {
          [all_id]: []
        };
      },
      computed: {
        [local_id]: function () {
          var local;
          cb.call(this, chk.bind(null, this[all_id] = [], local = []));
          return local;
        }
      },
      watch: {
        [local_id]: function (local) {
          var ary;
          ary = _.difference(this[id], this[all_id]);
          ary = _.union(ary, local);
          return this.$emit(`update:${id}`, ary);
        }
      }
    };
  },
  form: function (id, cb, origin) {
    var base_id, init_id, is_edit_id, keys, origin_id;
    origin_id = `${id}_origin`;
    base_id = `${id}_base`;
    init_id = `${id}_init`;
    is_edit_id = `is_${id}_edit`;
    keys = [];
    return {
      data: function () {
        var base, form, i, key, len;
        form = cb.call(this);
        keys = Object.keys(form);
        base = {};

        for (i = 0, len = keys.length; i < len; i++) {
          key = keys[i];
          form[key] = base[key] = null;
        }

        return {
          [id]: form,
          [base_id]: base
        };
      },
      computed: {
        [origin_id]: origin,
        [is_edit_id]: function () {
          return !_.isEqual(this[id], this[base_id]);
        }
      },
      methods: {
        [init_id]: function (src) {
          var i, key, len, results;
          results = [];

          for (i = 0, len = keys.length; i < len; i++) {
            key = keys[i];
            results.push(this[id][key] = this[base_id][key] = src[key]);
          }

          return results;
        }
      },
      watch: {
        [origin_id]: function (o) {
          return this[init_id](o);
        }
      }
    };
  }
};

/***/ }),

/***/ "./src/index.coffee":
/*!**************************!*\
  !*** ./src/index.coffee ***!
  \**************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


__webpack_require__(/*! ./fancy-date-sample */ "./src/fancy-date-sample.coffee");

module.exports = {
  FancyDate: __webpack_require__(/*! ./fancy-date */ "./src/fancy-date.coffee"),
  ...__webpack_require__(/*! ./struct */ "./src/struct.coffee"),
  ...__webpack_require__(/*! ./time */ "./src/time.coffee"),
  ...__webpack_require__(/*! ./timer */ "./src/timer.coffee"),
  ...__webpack_require__(/*! ./uri */ "./src/uri.coffee"),
  ...__webpack_require__(/*! ./curtain */ "./src/curtain.coffee"),
  ...__webpack_require__(/*! ./observer */ "./src/observer.coffee"),
  ...__webpack_require__(/*! ./storage */ "./src/storage.coffee"),
  ...__webpack_require__(/*! ./firebase */ "./src/firebase.coffee"),
  ...__webpack_require__(/*! ./device */ "./src/device.coffee"),
  ...__webpack_require__(/*! ./poll */ "./src/poll.coffee"),
  ...__webpack_require__(/*! ./path */ "./src/path.coffee"),
  ...__webpack_require__(/*! ./vue */ "./src/vue.coffee"),
  ...__webpack_require__(/*! ./form */ "./src/form.coffee")
};

/***/ }),

/***/ "./src/observer.coffee":
/*!*****************************!*\
  !*** ./src/observer.coffee ***!
  \*****************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _, intersectionBase, resize_observer;

_ = __webpack_require__(/*! lodash */ "lodash");

intersectionBase = function (option) {
  var observer;
  observer = typeof IntersectionObserver !== "undefined" && IntersectionObserver !== null ? new IntersectionObserver(function (doms) {
    return doms.forEach(function (o) {
      return o.target._cb_intersection({
        is_hit: o.isIntersecting,
        ratio: o.intersectionRatio,
        cross: o.intersectionRect,
        bound: o.boundingClientRect,
        root: o.rootBounds
      });
    });
  }, option) : {
    observe: function () {},
    unobserve: function () {},
    disconnect: function () {}
  };
  return function (id) {
    var default_id;
    default_id = `${id}_default`;
    return {
      bind: function (el, binding, {
        context
      }) {
        var vm;
        vm = context;
        vm[default_id] = _.get(vm, id);
        return _.set(vm, id, null);
      },
      // vm[type_id] = types[vm[default_id].constructor]
      inserted: function (el, binding, {
        context
      }) {
        var cb;

        cb = function (o) {
          return _.set(this, id, o.is_hit ? this[default_id] : null);
        };

        el._cb_intersection = cb.bind(context);
        return observer.observe(el);
      },
      unbind: function (el) {
        return observer.unobserve(el);
      }
    };
  };
}; // observer.disconnect


resize_observer = typeof ResizeObserver !== "undefined" && ResizeObserver !== null ? new ResizeObserver(function (doms) {
  return doms.forEach(function (o) {
    var height, width;
    ({
      width,
      height
    } = o.contentRect);
    width = parseInt(width);
    height = parseInt(height);
    return o.target._cb_resize({
      width,
      height
    });
  });
}) : {
  observe: function () {},
  unobserve: function () {},
  disconnect: function () {}
};
module.exports = {
  resize: function (id) {
    var default_id, observer, type_id;
    default_id = `${id}_default`;
    type_id = `${id}_type`;
    observer = resize_observer;
    return {
      bind: function (el, binding, {
        context
      }) {
        var vm;
        vm = context;
        return vm[default_id] = _.get(vm, id);
      },
      // vm[type_id] = types[vm[default_id].constructor]
      inserted: function (el, binding, {
        context
      }) {
        var cb;

        cb = function (size) {
          return _.set(this, id, size);
        };

        el._cb_resize = cb.bind(context);
        return observer.observe(el);
      },
      unbind: function (el) {
        observer.unobserve(el);
        return observer.disconnect(el);
      }
    };
  },
  on_horizon: intersectionBase({
    root: null,
    rootMargin: '-50% 0% -50% 0%',
    threshold: [0]
  }),
  on_peek: intersectionBase({
    root: null,
    rootMargin: '25%',
    threshold: [0]
  }),
  on_appear: intersectionBase({
    root: null,
    rootMargin: '0%',
    threshold: [0.5]
  })
};

/***/ }),

/***/ "./src/path.coffee":
/*!*************************!*\
  !*** ./src/path.coffee ***!
  \*************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var Query, m;
({
  Query
} = __webpack_require__(/*! memory-orm */ "memory-orm"));
module.exports = m = {
  path_by: function (idx = 'idx', keys) {
    var computed, idx_a;
    idx_a = `${idx}_a`;
    computed = {};
    computed[idx_a] = {
      get: function () {
        var ref;
        return ((ref = this[idx]) != null ? ref.split("-") : void 0) || [];
      }
    };
    keys.forEach(function (name, at) {
      var key, list;

      if (!name) {
        return;
      }

      key = `${name}_id`;
      list = `${name}s`;
      computed[key] = {
        get: function () {
          if (at < this[idx_a].length) {
            return this[idx_a].slice(0, +at + 1 || 9e9).join("-");
          }
        }
      };
      return computed[name] = {
        get: function () {
          return Query[list].find(this[key]);
        }
      };
    });
    return {
      computed
    };
  }
};

/***/ }),

/***/ "./src/poll.coffee":
/*!*************************!*\
  !*** ./src/poll.coffee ***!
  \*************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }

function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }

var Mem,
    dexie,
    is_cache,
    is_online,
    is_visible,
    poll,
    poll_request,
    to_tempo,
    splice = [].splice;
Mem = __webpack_require__(/*! memory-orm */ "memory-orm");
dexie = null;

poll_request = function () {
  var Dexie;

  if (typeof document === "undefined" || document === null) {
    return;
  }

  Dexie = __webpack_require__(/*! dexie */ "dexie").default;
  dexie = new Dexie('poll-web');
  dexie.version(1).stores({
    meta: '&idx',
    data: '&idx'
  });
  return poll_request = function () {};
};

({
  to_tempo
} = __webpack_require__(/*! ./time */ "./src/time.coffee")); // has_last = {}

is_cache = {};
is_online = is_visible = false;

poll = function (cb) {
  return {
    mounted: function () {
      poll_request();
      this.timers = {};
      window.addEventListener('offline', this._waitwake);
      window.addEventListener('online', this._waitwake);
      document.addEventListener('visibilitychange', this._waitwake);
      return this._waitwake();
    },
    destroyed: function () {
      var key, ref, results, val;
      window.removeEventListener('offline', this._waitwake);
      window.removeEventListener('online', this._waitwake);
      document.removeEventListener('visibilitychange', this._waitwake);
      ref = this.timers;
      results = [];

      for (key in ref) {
        val = ref[key];
        results.push(clearTimeout(val));
      }

      return results;
    },
    methods: {
      get_by_network: function () {
        var key, list, ref, val;
        ref = this.timers;

        for (key in ref) {
          val = ref[key];
          clearTimeout(val);
        }

        list = cb.call(this);
        list.map(([name, id]) => {
          var idx;
          idx = [name, id].join("&");
          dexie.meta.delete(idx);
          dexie.data.delete(idx);
          return is_cache[idx] = 0;
        });
        return this._waitwake();
      },
      _waitwake: (() => {
        var _ref = _asyncToGenerator(function* () {
          var _this = this;

          var is_ok, key, list, ref, results, val;
          is_online = window.navigator.onLine;
          is_visible = 'hidden' !== document.visibilityState;
          is_ok = is_online && is_visible;

          if (is_ok) {
            list = cb.call(this);
            return yield Promise.all(list.map(function ([name, id]) {
              return _this.$store.dispatch(name, {
                id,
                name,
                timers: _this.timers
              });
            }));
          } else {
            ref = this.timers;
            results = [];

            for (key in ref) {
              val = ref[key];
              results.push(clearTimeout(val));
            }

            return results;
          }
        });

        return function _waitwake() {
          return _ref.apply(this, arguments);
        };
      })()
    }
  };
};

poll.cache = function (timestr = "10s", version = "1.0.0", vuex_id, cb) {
  // console.log { timestr, timeout, url: cb('*') }
  return function ({
    dispatch,
    state,
    commit,
    rootState
  }, {
    id,
    name,
    timers
  }) {
    var idx, roop, url;
    url = cb(id);
    idx = [name, id].join("&");

    roop = (() => {
      var _ref2 = _asyncToGenerator(function* () {
        var e, get_by_lf, get_by_network, get_pass, last_at, meta, next_at, timeout, write_at;
        ({
          last_at,
          write_at,
          next_at,
          timeout
        } = to_tempo(timestr));

        get_pass = function () {
          var wait;
          wait = new Date() - write_at;
          return console.log({
            timestr,
            idx,
            wait,
            url: null
          });
        };

        get_by_lf = (() => {
          var _ref3 = _asyncToGenerator(function* () {
            var meta, wait;
            meta = yield dexie.data.get(idx);
            Mem.State.store(meta);
            wait = new Date() - write_at;
            return console.log({
              timestr,
              idx,
              wait,
              url: '(LF)'
            });
          });

          return function get_by_lf() {
            return _ref3.apply(this, arguments);
          };
        })();

        get_by_network = (() => {
          var _ref4 = _asyncToGenerator(function* () {
            var meta, wait;
            meta = yield poll._api[name](url, id);
            meta.idx = idx;
            yield dexie.data.put(meta);
            wait = new Date() - write_at;
            return console.log({
              timestr,
              idx,
              wait,
              url
            });
          });

          return function get_by_network() {
            return _ref4.apply(this, arguments);
          };
        })();

        try {
          if (write_at < is_cache[idx]) {
            get_pass();
          } else {
            // IndexedDB metadata not use if memory has past data, 
            if (!(0 < is_cache[idx])) {
              meta = yield dexie.meta.get(idx);

              if ((meta != null ? meta.version : void 0) !== version) {
                meta = null;
              }
            }

            switch (false) {
              case !(write_at < (meta != null ? meta.next_at : void 0)):
                yield get_by_lf();
                break;

              case !(0 < (meta != null ? meta.next_at : void 0)):
                yield get_by_lf();
                yield get_by_network();
                break;

              default:
                yield get_by_network();
                dexie.meta.put({
                  idx,
                  version,
                  next_at
                });
            }
          }

          is_cache[idx] = next_at;
        } catch (error) {
          e = error;
          console.error(e);
        }

        if (timeout < 0x7fffffff) {
          //  ほぼ25日
          return timers[url] = setTimeout(roop, timeout);
        }
      });

      return function roop() {
        return _ref2.apply(this, arguments);
      };
    })();

    return roop();
  };
};

poll.caches = function (...arg) {
  var actions, cb, key, ref, timestr, version;
  ref = arg, [...arg] = ref, [actions] = splice.call(arg, -1);
  [timestr, version] = arg;

  for (key in actions) {
    cb = actions[key];
    actions[key] = poll.cache(timestr, version, key, cb);
  }

  return actions;
};

poll._api = {
  fetch: (() => {
    var _ref5 = _asyncToGenerator(function* (url, cb) {
      var data, res;
      res = yield fetch(url);
      data = yield res.json();
      return Mem.State.transaction(function () {
        return cb(data);
      });
    });

    return function fetch(_x, _x2) {
      return _ref5.apply(this, arguments);
    };
  })()
};

poll.api = function (o) {
  return Object.assign(poll._api, o);
};

module.exports = {
  poll
};

/***/ }),

/***/ "./src/storage.coffee":
/*!****************************!*\
  !*** ./src/storage.coffee ***!
  \****************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var $cookie_storage, $local_storage, $session_storage, Cookie, _, capture, m, relative_to, types;

_ = __webpack_require__(/*! lodash */ "lodash");
Cookie = __webpack_require__(/*! tiny-cookie */ "tiny-cookie");
({
  types,
  relative_to
} = __webpack_require__(/*! ./struct */ "./src/struct.coffee"));
$session_storage = {};
$local_storage = {};
$cookie_storage = {};

capture = function (s, type, _default) {
  if (s != null) {
    return type.by_str(s);
  } else {
    return _default;
  }
};

module.exports = m = {
  sessionStorage: function (id) {
    var default_id, global_id, type_id;
    global_id = `$data.$session_storage.${id}`;
    default_id = `${id}_default`;
    type_id = `${id}_type`;

    if (!_.has($session_storage, id)) {
      _.set($session_storage, id, null);
    }

    return {
      data: function () {
        return {
          $session_storage
        };
      },
      created: function () {
        this[default_id] = _.get(this, id);
        return this[type_id] = types[this[default_id].constructor];
      },
      mounted: function () {
        var s, val;
        s = window.sessionStorage.getItem(id);
        val = capture(s, this[type_id], this[default_id]);

        _.set(this, id, val);

        return _.set($session_storage, id, val);
      },
      watch: {
        [global_id]: function (val) {
          return _.set(this, id, val);
        },
        [id]: function (val) {
          var s;

          _.set($session_storage, id, val);

          if (val != null) {
            s = this[type_id].to_str(val);
            return window.sessionStorage.setItem(id, s);
          } else {
            return window.sessionStorage.removeItem(id);
          }
        }
      }
    };
  },
  localStorage: function (id) {
    var default_id, global_id, handle_id, type_id;
    global_id = `$data.$local_storage.${id}`;
    default_id = `${id}_default`;
    handle_id = `${id}_handle`;
    type_id = `${id}_type`;

    if (!_.has($local_storage, id)) {
      _.set($local_storage, id, null);
    }

    return {
      data: function () {
        return {
          $local_storage
        };
      },
      created: function () {
        this[default_id] = _.get(this, id);
        return this[type_id] = types[this[default_id].constructor];
      },
      mounted: function () {
        var s, val;
        s = window.localStorage.getItem(id);
        val = capture(s, this[type_id], this[default_id]);

        _.set(this, id, val);

        _.set($local_storage, id, val);

        this[handle_id] = ({
          key,
          newValue
        }) => {
          if (key === id) {
            val = capture(newValue, this[type_id], this[default_id]);

            _.set(this, id, val);

            return _.set($local_storage, id, val);
          }
        };

        return window.addEventListener("storage", this[handle_id]);
      },
      beforeDestroy: function () {
        return window.removeEventListener("storage", this[handle_id]);
      },
      watch: {
        [global_id]: function (val) {
          return _.set(this, id, val);
        },
        [id]: function (val) {
          var s;

          _.set($local_storage, id, val);

          if (val != null) {
            s = this[type_id].to_str(val);
            return window.localStorage.setItem(id, s);
          } else {
            return window.localStorage.removeItem(id);
          }
        }
      }
    };
  },
  cookie: function (id, options = {
    expires: '1M'
  }) {
    var default_id, global_id, type_id;
    global_id = `$data.$cookie_storage.${id}`;
    default_id = `${id}_default`;
    type_id = `${id}_type`;

    if (!_.has($cookie_storage, id)) {
      _.set($cookie_storage, id, null);
    }

    return {
      data: function () {
        return {
          $cookie_storage
        };
      },
      created: function () {
        this[default_id] = _.get(this, id);
        return this[type_id] = types[this[default_id].constructor];
      },
      mounted: function () {
        var s, val;
        s = Cookie.get(id);
        val = capture(s, this[type_id], this[default_id]);

        _.set(this, id, val);

        return _.set($cookie_storage, id, val);
      },
      watch: {
        [global_id]: function (val) {
          return _.set(this, id, val);
        },
        [id]: function (val) {
          var s;

          _.set($cookie_storage, id, val);

          if (val != null) {
            s = this[type_id].to_str(val);
            return Cookie.set(id, s, options);
          } else {
            return Cookie.remove(id);
          }
        }
      }
    };
  }
};

/***/ }),

/***/ "./src/struct.coffee":
/*!***************************!*\
  !*** ./src/struct.coffee ***!
  \***************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _, relative_to, simple_route, to_Array, to_Number, to_String, zero;

_ = __webpack_require__(/*! lodash */ "lodash");
zero = [null, void 0, "", 0 / 0];

simple_route = function (o) {
  var key, ref, val;
  ref = o.query;

  for (key in ref) {
    val = ref[key];

    if (zero.includes(val)) {
      delete o.query[key];
    }
  }

  return o;
};

relative_to = function ({
  name,
  params,
  query,
  hash
}, o, is_replace) {
  var key, tgt, to, val;

  if (!is_replace) {
    params = _.cloneDeep(params);
    query = _.cloneDeep(query);
  }

  to = {
    name,
    params,
    query,
    hash
  };

  for (key in o) {
    val = o[key];
    tgt = params.hasOwnProperty(key) ? params : query;
    tgt[key] = val;
  }

  return simple_route(to);
};

to_String = function (nil) {
  return function (u) {
    if (zero.includes(u)) {
      return nil;
    } else {
      return String(u);
    }
  };
};

to_Number = function (u) {
  if (zero.includes(u)) {
    return 0 / 0;
  } else {
    return Number(u);
  }
};

to_Array = function (u) {
  if (zero.includes(u)) {
    return [];
  } else {
    if (u instanceof Array) {
      return u;
    } else {
      return Array(u);
    }
  }
};

module.exports = {
  simple_route,
  relative_to,
  types: {
    [Number]: {
      to_str: to_String(""),
      by_str: to_Number,
      by_url: to_Number
    },
    [String]: {
      to_str: to_String(""),
      by_str: to_String(void 0),
      by_url: to_String("")
    },
    [Array]: {
      to_str: function (o) {
        return JSON.stringify(o) || [];
      },
      by_str: function (o) {
        return JSON.parse(o) || [];
      },
      by_url: to_Array
    },
    [Object]: {
      to_str: function (o) {
        return JSON.stringify(o) || {};
      },
      by_str: function (o) {
        return JSON.parse(o) || {};
      }
    }
  }
};

/***/ }),

/***/ "./src/time.coffee":
/*!*************************!*\
  !*** ./src/time.coffee ***!
  \*************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var DAY,
    DISTANCES,
    DISTANCE_LONG_AGO,
    DISTANCE_NAN,
    HOUR,
    INTERVAL,
    MINUTE,
    MONTH,
    SECOND,
    TIMERS,
    TIMEZONE_OFFSET_JP,
    Tempo,
    VALID,
    WEEK,
    YEAR,
    m,
    tempo_gap,
    timezone,
    to_msec,
    to_relative_time_distance,
    to_sec,
    to_tempo,
    to_tempo_bare,
    to_tempo_by,
    to_timer,
    splice = [].splice;
Tempo = class Tempo {
  constructor(...args) {
    var callback, ref;
    ref = args, [...args] = ref, [callback] = splice.call(args, -1);
    this.args = args;
    this.callback = callback;
    this.tempo = to_tempo(this.args[0], this.args[1], new Date(0));
  }

  tick() {
    var tempo;
    tempo = to_tempo(...this.args);

    if (this.tempo.now_idx === tempo.now_idx) {
      return;
    }

    this.callback(tempo);
    return this.tempo = tempo;
  }

};

to_msec = function (str) {
  return 1000 * to_sec(str);
};

to_sec = function (str) {
  var timeout;
  timeout = 0;
  str.replace(/(\d+)([ヵ]?([smhdwy秒分時日週月年])[間]?(半$)?)|0/g, function (full, num, fullunit, unit, appendix) {
    if (!(num = Number(num))) {
      return null;
    }

    if ('半' === appendix) {
      num += 0.5;
    }

    return timeout += num * function () {
      switch (unit) {
        case "s":
        case "秒":
          return 1;

        case "m":
        case "分":
          return 60;

        case "h":
        case "時":
          return 3600;

        case "d":
        case "日":
          return 3600 * 24;

        case "w":
        case "週":
          return 3600 * 24 * 7;

        case "y":
        case "年":
          return 31556925.147;
        // 2019 average.

        default:
          throw new Error(`${str} at ${num}${unit}`);
      }
    }();
  });
  return timeout;
};

to_timer = function (msec, unit_mode = 1) {
  var base, i, idx, len, o, str, unit;
  str = "";

  for (i = 0, len = TIMERS.length; i < len; i++) {
    o = TIMERS[i];
    unit = o[unit_mode];
    base = o[2];

    if (idx = Math.floor(msec / base)) {
      str += `${idx}${unit}`;
    }

    msec = msec % base;
  }

  return str;
};

to_relative_time_distance = function (msec) {
  var i, idx, len, limit;

  if (msec < -VALID || VALID < msec || msec - 0 === 0 / 0) {
    return DISTANCE_NAN;
  }

  for (idx = i = 0, len = DISTANCES.length; i < len; idx = ++i) {
    [limit] = DISTANCES[idx];

    if (msec < limit) {
      return DISTANCES[idx];
    }
  }

  return DISTANCE_LONG_AGO;
};

to_tempo = function (size, gap_str = "0s", write_at = new Date()) {
  var gap;
  size = to_msec(size);
  gap = to_msec(gap_str) + tempo_gap;
  return to_tempo_bare(size, gap, write_at - 0, 0);
};

to_tempo_bare = function (size, gap, write_at) {
  var last_at, next_at, now_idx, remain, since, timeout;
  now_idx = Math.floor((write_at - gap) / size);
  last_at = (now_idx + 0) * size + gap;
  next_at = (now_idx + 1) * size + gap;
  remain = next_at - write_at;
  since = write_at - last_at;
  timeout = remain;
  return {
    last_at,
    write_at,
    next_at,
    timeout,
    now_idx,
    remain,
    since,
    gap,
    size
  };
};
/*
to_tempo_by = (table, gap, write_at)->
scan_at = write_at - gap
if scan_at < 0
  now_idx = -1
  next_at = gap
  last_at = -Infinity
else
  last_at = 0
  for next_at, now_idx in table
    unless scan_at < next_at
      last_at = next_at
      continue
    break

  if last_at == next_at
    next_at = Infinity
  next_at += gap
  last_at += gap

size   =  next_at -  last_at
remain =  next_at - write_at
since  = write_at -  last_at
timeout = remain

{ last_at, write_at, next_at, timeout, now_idx, remain, since, gap, size, scan_at, table }
*/
// バイナリサーチ 高速化はするが、微差なので複雑さのせいで逆に遅いかも？


to_tempo_by = function (table, gap, write_at) {
  var last_at, mid_idx, next_at, now_idx, remain, scan_at, since, size, timeout, top_idx;
  scan_at = write_at - gap;

  if (scan_at < 0) {
    now_idx = -1;
    next_at = gap;
    last_at = -2e308;
  } else {
    top_idx = 0;
    now_idx = table.length;

    while (top_idx < now_idx) {
      mid_idx = top_idx + now_idx >>> 1;
      next_at = table[mid_idx];

      if (next_at <= scan_at) {
        top_idx = mid_idx + 1;
      } else {
        now_idx = mid_idx;
      }
    }

    next_at = table[now_idx] || 2e308;
    last_at = table[now_idx - 1] || 0;
    next_at += gap;
    last_at += gap;
  }

  size = next_at - last_at;
  remain = next_at - write_at;
  since = write_at - last_at;
  timeout = remain;
  return {
    last_at,
    write_at,
    next_at,
    timeout,
    now_idx,
    remain,
    since,
    gap,
    size,
    scan_at,
    table
  };
};

SECOND = to_msec("1s");
MINUTE = to_msec("1m");
HOUR = to_msec("1h");
DAY = to_msec("1d");
WEEK = to_msec("1w");
INTERVAL = 0x7fffffff; // 31bits.

MONTH = to_msec("30d");
YEAR = to_msec("1y");
VALID = 0xfffffffffffff; // 52 bits.

TIMEZONE_OFFSET_JP = to_msec("-9h");
timezone = typeof window !== "undefined" && window !== null ? MINUTE * new Date().getTimezoneOffset() : TIMEZONE_OFFSET_JP;
tempo_gap = -new Date(0).getDay() * DAY + timezone;
TIMERS = [["年", "y", YEAR], ["週", "w", WEEK], ["日", "d", DAY], ["時", "h", HOUR], ["分", "m", MINUTE], ["秒", "s", SECOND]];
DISTANCES = [DISTANCE_NAN = [-VALID, INTERVAL, YEAR, "？？？"], [-YEAR, INTERVAL, YEAR, "%s年後"], [-MONTH, INTERVAL, MONTH, "%sヶ月後"], [-WEEK, WEEK, WEEK, "%s週間後"], [-DAY, DAY, DAY, "%s日後"], [-HOUR, HOUR, HOUR, "%s時間後"], [-MINUTE, MINUTE, MINUTE, "%s分後"], [-25000, SECOND, SECOND, "%s秒後"], [25000, 25000, 25000, "今"], [MINUTE, SECOND, SECOND, "%s秒前"], [HOUR, MINUTE, MINUTE, "%s分前"], [DAY, HOUR, HOUR, "%s時間前"], [WEEK, DAY, DAY, "%s日前"], [MONTH, WEEK, WEEK, "%s週間前"], [YEAR, INTERVAL, MONTH, "%sヶ月前"], [VALID, INTERVAL, YEAR, "%s年前"], DISTANCE_LONG_AGO = [2e308, INTERVAL, VALID, "昔"]];
module.exports = m = {
  Tempo,
  to_timer,
  to_msec,
  to_sec,
  to_tempo,
  to_tempo_bare,
  to_tempo_by,
  to_relative_time_distance,
  timezone
};

/***/ }),

/***/ "./src/timer.coffee":
/*!**************************!*\
  !*** ./src/timer.coffee ***!
  \**************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var Tempo,
    _,
    debounces,
    delays,
    relative,
    throttles,
    time_base,
    to_msec,
    to_relative_time_distance,
    to_tempo_bare,
    splice = [].splice;

_ = __webpack_require__(/*! lodash */ "lodash");
({
  to_msec,
  to_tempo_bare,
  to_relative_time_distance
} = __webpack_require__(/*! ./time */ "./src/time.coffee"));
Tempo = class Tempo {
  constructor(...args) {
    var cb1, ref;
    ref = args, [...args] = ref, [cb1] = splice.call(args, -1);
    this.args = args;
    this.cb = cb1;
    this.tempo = to_tempo(this.args[0], this.args[1] || "0s", new Date(0));
  }

  tick() {
    var tempo;
    tempo = to_tempo(...this.args);

    if (this.tempo.now_idx === tempo.now_idx) {
      return;
    }

    this.cb(tempo);
    return this.tempo = tempo;
  }

};

time_base = function (method) {
  return function (id, {
    times
  }) {
    var default_id, tail_funcs, tail_ids;
    default_id = `${id}_default`;
    tail_ids = `${id}_tail_ids`;
    tail_funcs = `${id}_tail_funcs`;
    return {
      data: function () {
        var o;
        o = {};
        times.forEach(time => {
          var tail_id;
          tail_id = `${id}_${time}`;
          return _.set(o, tail_id, null);
        });
        return o;
      },
      created: function () {
        var id_value;
        this[tail_ids] = [];
        this[tail_funcs] = [];
        id_value = _.get(this, id);
        times.forEach(time => {
          var msec, tail_id;
          msec = to_msec(time);
          tail_id = `${id}_${time}`;

          _.set(this, tail_id, id_value);

          this[tail_ids].push(tail_id);
          return this[tail_funcs].push(method(value => {
            return _.set(this, tail_id, value);
          }, msec));
        });
        return this[default_id] = id_value;
      },
      watch: {
        [id]: function (newValue) {
          var i, idx, len, ref, results, tail_func;
          ref = this[tail_funcs];
          results = [];

          for (idx = i = 0, len = ref.length; i < len; idx = ++i) {
            tail_func = ref[idx];
            results.push(tail_func(newValue));
          }

          return results;
        }
      }
    };
  };
};

debounces = time_base(_.debounce);
throttles = time_base(_.throttle);
delays = time_base(function (cb, msec) {
  return function (value) {
    return setTimeout(cb, msec, value);
  };
});

relative = function (id, {
  limit,
  format
} = {}) {
  var distance_id, interval_id, limit_id, msec_id, now_id, tempo_id, text_id, tick_id;
  now_id = `${id}_now`;
  msec_id = `${id}_msec`;
  tick_id = `${id}_tick`;
  text_id = `${id}_text`;
  limit_id = `${id}_limit`;
  tempo_id = `${id}_tempo`;
  distance_id = `${id}_distance`;
  interval_id = `${id}_interval`;
  return {
    data: function () {
      return {
        [now_id]: Date.now(),
        [limit_id]: to_msec(limit)
      };
    },
    computed: {
      [msec_id]: function () {
        return this[now_id] - new Date(this[id]).getTime();
      },
      [distance_id]: function () {
        return to_relative_time_distance(this[msec_id]);
      },
      [tempo_id]: function () {
        var interval;
        [, interval] = this[distance_id];
        return to_tempo_bare(interval, 0, this[msec_id]);
      },
      [text_id]: function () {
        var limit_msec, msec, now_idx, text;
        msec = this[msec_id];
        limit_msec = this[limit_id];
        [,,, text] = this[distance_id];
        ({
          now_idx
        } = this[tempo_id]);

        if (limit_msec < msec) {
          clearInterval(this[interval_id]);
          this[interval_id] = null;
          return format(this[id]);
        }

        this[tick_id];

        if (msec < -limit_msec) {
          return format(this[id]);
        }

        return text.replace('%s', Math.abs(now_idx));
      },
      [tick_id]: function () {
        var timeout;
        ({
          timeout
        } = this[tempo_id]);

        if (this[interval_id]) {
          clearInterval(this[interval_id]);
        }

        this[interval_id] = setInterval(() => {
          this[now_id] = Date.now();
          return this[tick_id];
        }, timeout);
      }
    },
    beforeDestroy: function () {
      clearInterval(this[interval_id]);
      return this[interval_id] = null;
    }
  };
};

module.exports = {
  relative,
  delays,
  debounces,
  throttles
};

/***/ }),

/***/ "./src/uri.coffee":
/*!************************!*\
  !*** ./src/uri.coffee ***!
  \************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _, m, relative_to, routeBase, types, zero;

_ = __webpack_require__(/*! lodash */ "lodash");
({
  types,
  relative_to
} = __webpack_require__(/*! ./struct */ "./src/struct.coffee"));
zero = [null, void 0, "", 0 / 0];

routeBase = function (change_url) {
  return function (id) {
    var default_id, route_into, type_id;
    default_id = `${id}_default`;
    type_id = `${id}_type`;

    route_into = function (newRoute, oldRoute) {
      var s, val;
      s = newRoute.params[id] || newRoute.query[id];
      val = zero.includes(s) ? this[default_id] : this[type_id].by_url(s);
      return _.set(this, id, val);
    };

    return {
      created: function () {
        this[default_id] = _.get(this, id);
        return this[type_id] = types[this[default_id].constructor];
      },
      // for changed component.
      mounted: function () {
        var s, val;
        s = this.$route.params[id] || this.$route.query[id];

        if (!zero.includes(s)) {
          val = this[type_id].by_url(s);
          return _.set(this, id, val);
        }
      },
      // for same component but uri changed.
      beforeRouteEnter: function (newRoute, oldRoute, next) {
        return next(function (vm) {
          return route_into.call(vm, newRoute, oldRoute);
        });
      },
      // for same component but uri changed.
      beforeRouteUpdate: function (newRoute, oldRoute, next) {
        next();
        return route_into.call(this, newRoute, oldRoute);
      },
      watch: {
        [id]: function (newVal) {
          var href, location;
          ({
            location,
            href
          } = this.$router.resolve(relative_to(this.$route, {
            [id]: newVal
          }, true)));
          return change_url.call(this, href);
        }
      }
    };
  };
};

module.exports = m = {
  replaceState: routeBase(function (href) {
    return history.replaceState(null, null, href);
  }),
  pushState: routeBase(function (href) {
    return history.pushState(null, null, href);
  })
};

/***/ }),

/***/ "./src/vue.coffee":
/*!************************!*\
  !*** ./src/vue.coffee ***!
  \************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var $shared_memory, _, m;

_ = __webpack_require__(/*! lodash */ "lodash");
$shared_memory = {};
module.exports = m = {
  share: function (id) {
    if ($shared_memory[id] == null) {
      $shared_memory[id] = null;
    }

    return {
      data: function () {
        return {
          $shared_memory
        };
      },
      computed: {
        [id]: {
          get: function () {
            return $shared_memory[id];
          },
          set: function (o) {
            return $shared_memory[id] = o;
          }
        }
      }
    };
  },
  vuex_read: function (id, opt) {
    var dir, getter;
    dir = (opt.on || "").split('.');
    getter = [...dir.slice(0), id].join('.');
    return {
      computed: {
        [id]: {
          get: function () {
            return _.get(this.$store.state, getter);
          }
        }
      }
    };
  },
  vuex: function (id, opt) {
    var dir, getter, mutation, setter;
    dir = (opt.on || "").split('.');
    mutation = [dir[0], 'update'].join('/');
    getter = [...dir.slice(0), id].join('.');
    setter = [...dir.slice(1), id].join('.');
    return {
      computed: {
        [id]: {
          get: function () {
            return _.get(this.$store.state, getter);
          },
          set: function (val) {
            var o;
            o = _.set({}, setter, val);
            return this.$store.commit(mutation, o);
          }
        }
      }
    };
  }
};

/***/ }),

/***/ "dexie":
/*!************************!*\
  !*** external "dexie" ***!
  \************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = require("dexie");

/***/ }),

/***/ "firebase/app":
/*!*******************************!*\
  !*** external "firebase/app" ***!
  \*******************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = require("firebase/app");

/***/ }),

/***/ "firebase/firestore":
/*!*************************************!*\
  !*** external "firebase/firestore" ***!
  \*************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = require("firebase/firestore");

/***/ }),

/***/ "lodash":
/*!*************************!*\
  !*** external "lodash" ***!
  \*************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = require("lodash");

/***/ }),

/***/ "memory-orm":
/*!*****************************!*\
  !*** external "memory-orm" ***!
  \*****************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = require("memory-orm");

/***/ }),

/***/ "tiny-cookie":
/*!******************************!*\
  !*** external "tiny-cookie" ***!
  \******************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = require("tiny-cookie");

/***/ })

/******/ });
});
//# sourceMappingURL=index.min.js.map