(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define([], factory);
	else if(typeof exports === 'object')
		exports["VuePetitStore"] = factory();
	else
		root["VuePetitStore"] = factory();
})(global, function() {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./src/index.coffee");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./src/fancy-date.coffee":
/*!*******************************!*\
  !*** ./src/fancy-date.coffee ***!
  \*******************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.FancyDate = void 0;

var Indexer,
    _,
    by_tempo,
    calc_set,
    daily_define,
    daily_measure,
    default_format_format,
    default_parse_format,
    reg_parse,
    reg_token,
    sub_define,
    timezone,
    to_msec,
    to_sec,
    to_tempo_bare,
    to_tempo_by,
    to_timer,
    splice = [].splice,
    slice = [].slice,
    modulo = function (a, b) {
  return (+a % (b = +b) + b) % b;
};

({
  timezone,
  by_tempo,
  to_timer,
  to_msec,
  to_sec,
  to_tempo_by,
  to_tempo_bare
} = __webpack_require__(/*! ./time */ "./src/time.coffee"));
_ = __webpack_require__(/*! lodash */ "lodash");
reg_parse = /(\d+)年(\d+)月(\d+)日\(([^)])\)(\d+)時(\d+)分(\d+)秒/;
reg_token = /[yYQqMLwIdDecihHKkms]o|(\w)\1*|''|'(''|[^'])+('|$)|./g;
default_parse_format = "y年M月d日";
default_format_format = "Gy年M月d日(E)H時m分s秒";

calc_set = function (path, o) {
  var key, results, val;
  results = [];

  for (key in o) {
    val = o[key];
    results.push(this.calc[path][key] = (val != null ? val[path] : void 0) || val);
  }

  return results;
};

sub_define = function (msec, size) {
  var range;
  range = [size];
  msec = msec / size;
  return {
    range,
    msec
  };
};

daily_define = function (msec, day) {
  var range;
  range = [Math.floor(msec / day)];
  msec = range[0] * day;
  return {
    range,
    msec
  };
};

daily_measure = function (msec, day) {
  var range;
  range = [Math.floor(msec / day), Math.ceil(msec / day)];
  return {
    range,
    msec
  };
};

Indexer = class Indexer {
  constructor(dic, code, label, idx1, list) {
    this.idx = idx1;
    this.label = label;

    if (list) {
      if (list.length) {
        dic.list[code] = list;
        this.list = list;
        this.length = list.length;
      } else {
        this.length = list;
      }
    } else {}
  }

  at(idx) {
    if (this.list) {
      return this.list[idx];
    } else {
      return idx;
    }
  }

};
var FancyDate = class FancyDate {
  constructor(o) {
    if (o) {
      ({
        dic: this.dic,
        calc: this.calc
      } = _.cloneDeep(o));
    } else {
      this.dic = {
        list: {}
      };
      this.calc = {
        eras: [],
        divs: {},
        idx: {},
        zero: {},
        msec: {},
        range: {}
      };
    }
  }

  dup() {
    return new this.constructor(this);
  }

  planet([revolution, spring], moon_args, [rotation, rotation_zero], axtial_tilt, geo) {
    var day, lat, lng, moon, synodic, synodic_zero, tz_offset, year;
    year = daily_measure(revolution, rotation);
    day = daily_define(rotation, rotation);

    if (moon_args) {
      [synodic, synodic_zero] = moon_args;
      moon = daily_measure(synodic, rotation);
    }

    calc_set.call(this, "range", {
      year,
      moon,
      day
    });
    calc_set.call(this, "msec", {
      year,
      moon,
      day
    });
    [lat, lng] = geo;
    tz_offset = rotation / 360 * lng;
    Object.assign(this.dic, {
      geo,
      lat,
      lng,
      axtial_tilt,
      spring,
      synodic_zero,
      rotation_zero,
      tz_offset
    });
    return this;
  }

  era(era, eras = []) {
    var G;
    G = new Indexer(this.dic, 'G', '', 0, ["紀元前", ...eras.map(([s]) => {
      return s;
    })]);
    Object.assign(this.dic, {
      era,
      eras
    });
    return this;
  }

  calendar(start, start_at, leaps = null, month_divs = null) {
    Object.assign(this.dic, {
      month_divs,
      leaps,
      start,
      start_at
    });
    return this;
  }

  rolls(weeks, etos) {
    if (weeks) {
      weeks = new Indexer(this.dic, 'E', ...weeks);
    }

    if (etos) {
      etos = new Indexer(this.dic, 'T', ...etos);
    }

    Object.assign(this.dic, {
      weeks,
      etos
    });
    return this;
  }

  yeary(months, days) {
    months = new Indexer(this.dic, 'M', ...months);
    days = new Indexer(this.dic, 'd', ...days);
    Object.assign(this.dic, {
      months,
      days
    });
    return this;
  }

  moony(moons) {
    moons = new Indexer(this.dic, 'N', ...moons);
    Object.assign(this.dic, {
      moons
    });
    return this;
  }

  seasonly(seasons) {
    seasons = new Indexer(this.dic, 'Z', ...seasons);
    Object.assign(this.dic, {
      seasons
    });
    return this;
  }

  daily(hours, minutes, seconds, is_solor = false) {
    hours = new Indexer(this.dic, 'H', ...hours);
    minutes = new Indexer(this.dic, 'm', ...minutes);
    seconds = new Indexer(this.dic, 's', ...seconds);
    Object.assign(this.dic, {
      hours,
      minutes,
      seconds,
      is_solor
    });
    return this;
  }

  init() {
    var D, E, G, H, J, M, N, S, T, Y, Z, a, at, d, e, f, hour, idx, key, list, m, minute, month, msec, ref, s, season, second, title, u, w, week, y, zero;

    G = (s, list) => {
      var idx;

      if (!list || (idx = list.indexOf(s) < 0)) {
        return s - 0;
      } else {
        return idx;
      }
    };

    T = Z = w = M = d = D = (s, list) => {
      var idx;

      if (!list || (idx = list.indexOf(s) < 0)) {
        return s - 1;
      } else {
        return idx;
      }
    };

    e = E = N = J = Y = y = u = H = m = s = S = s => {
      return s - 0;
    };

    this.dic.indexer = {
      G,
      u,
      Y,
      y,
      M,
      d,
      H,
      m,
      s,
      S,
      e,
      E,
      Z,
      N,
      T,
      D,
      w,
      J
    };

    at = function (list, now_idx) {
      if (list) {
        s = list[now_idx];

        if (s != null) {
          return s;
        }
      }
    };

    G = function (o) {
      return o.label;
    };

    M = function (o, list, length) {
      var ref;
      return `${o.is_leap ? "閏" : ""}${(ref = at(list, o.now_idx)) != null ? ref : _.padStart(o.now_idx + 1, length, '0')}`;
    };

    T = Z = w = d = D = (o, list, length) => {
      var ref;
      return (ref = at(list, o.now_idx)) != null ? ref : _.padStart(o.now_idx + 1, length, '0');
    };

    H = m = e = E = N = (o, list, length) => {
      var ref;
      return (ref = at(list, o.now_idx)) != null ? ref : _.padStart(o.now_idx, length, '0');
    };

    J = Y = y = u = s = (o, list, length) => {
      return _.padStart(o.now_idx, length, '0');
    };

    S = (o, list, length) => {
      return `${o.now_idx / this.calc.msec.second}`.slice(2);
    };

    this.dic.labeler = {
      G,
      u,
      Y,
      y,
      M,
      d,
      H,
      m,
      s,
      S,
      e,
      E,
      Z,
      N,
      T,
      D,
      w,
      J
    };
    season = sub_define(this.calc.msec.year, this.dic.seasons.length);
    month = daily_measure(this.calc.msec.year / this.dic.months.length, this.calc.msec.day);
    week = daily_define(this.dic.weeks.length * this.calc.msec.day, this.calc.msec.day);
    hour = sub_define(this.calc.msec.day, this.dic.hours.length);

    if (this.dic.is_solor) {
      minute = sub_define(hour.msec, this.dic.minutes.length);
      second = sub_define(minute.msec, minute.msec / 1000);
      calc_set.call(this, "range", {
        season,
        month,
        week,
        hour,
        minute,
        second
      });
      calc_set.call(this, "msec", {
        season,
        month,
        week,
        hour,
        minute,
        second
      });
    } else {
      minute = sub_define(hour.msec, this.dic.minutes.length);
      second = sub_define(minute.msec, minute.msec / 1000);
      calc_set.call(this, "range", {
        season,
        month,
        week,
        hour,
        minute,
        second
      });
      calc_set.call(this, "msec", {
        season,
        month,
        week,
        hour,
        minute,
        second
      });
    }

    this.def_table();
    Object.assign(this.calc.idx, this.def_idx());
    Object.assign(this.calc.zero, this.def_zero());
    zero = this.calc.zero.era;

    list = function () {
      var j, len, ref, results;
      ref = this.dic.eras;
      results = [];

      for (idx = j = 0, len = ref.length; j < len; idx = ++j) {
        [title, msec] = ref[idx];
        ({
          u
        } = this.to_tempos(msec));
        a = [title, msec, u.now_idx];
        this.calc.eras.push(a);
        results.push(msec - zero);
      }

      return results;
    }.call(this);

    list.push(2e308);
    this.table.msec.era = list;

    G = T = list => {
      return `(${list.join("|")})`;
    };

    M = d = H = m = e = E = Z = N = list => {
      if (list) {
        return `(${list.join("|")})`;
      } else {
        return "(\\d+)";
      }
    };

    D = w = u = Y = y = s = S = list => {
      return "(\\d+)";
    };

    J = list => {
      return "([\\d.]+)";
    };

    this.dic.regex = {};
    ref = {
      G,
      u,
      Y,
      y,
      M,
      d,
      H,
      m,
      s,
      S,
      e,
      E,
      Z,
      N,
      T,
      D,
      w,
      J
    };

    for (key in ref) {
      f = ref[key];
      this.dic.regex[key] = f(this.dic.list[key]);
    }

    return this;
  }

  def_table_by_leap_day() {
    var a, day, div, i, idx, is_leap, j, k, l, leaps, len, len1, len2, mode, month, month_divs, month_sum, months, period, range, ref, size, str, upto, year, years;
    day = this.calc.msec.day;

    upto = function (src) {
      var i, j, len, msec, results;
      msec = 0;
      results = [];

      for (j = 0, len = src.length; j < len; j++) {
        i = src[j];
        results.push(msec += i * day);
      }

      return results;
    };

    ref = this.dic.leaps, [...leaps] = ref, [period] = splice.call(leaps, -1);
    range = {
      year: function () {
        var j, k, len, ref1, results;
        results = [];

        for (idx = j = 0, ref1 = period; 0 <= ref1 ? j < ref1 : j > ref1; idx = 0 <= ref1 ? ++j : --j) {
          is_leap = 0;

          for (mode = k = 0, len = leaps.length; k < len; mode = ++k) {
            div = leaps[mode];

            if (idx % div) {
              continue;
            }

            is_leap = !mode % 2;
          }

          results.push(this.calc.range.year[is_leap]);
        }

        return results;
      }.call(this)
    };
    range.year[0] = this.calc.range.year[1];
    years = _.uniq(range.year);
    ({
      months,
      month_divs
    } = this.dic);

    if (!month_divs) {
      month_divs = function () {
        var j, len, results;
        results = [];

        for (idx = j = 0, len = months.length; j < len; idx = ++j) {
          str = months[idx];
          results.push(this.calc.range.month[1 - idx % 2]);
        }

        return results;
      }.call(this);

      month_divs[1] = 0;
    }

    month_sum = 0;

    for (j = 0, len = month_divs.length; j < len; j++) {
      i = month_divs[j];
      month_sum += i;
    }

    range.month = {};

    for (k = 0, len1 = years.length; k < len1; k++) {
      size = years[k];
      a = Array.from(month_divs);
      idx = month_divs.indexOf(0);
      a[idx] = size - month_sum;
      range.month[size] = a;
    }

    year = upto(range.year);
    period = year[year.length - 1];
    period = daily_define(period, day);
    calc_set.call(this, "msec", {
      period
    });
    month = {};

    for (l = 0, len2 = years.length; l < len2; l++) {
      size = years[l];
      month[size * day] = upto(range.month[size]);
    }

    this.table = {
      range,
      msec: {
        year,
        month
      }
    };
    return function ({
      size
    }, path) {
      switch (path) {
        case 'year':
          return year;

        case 'month':
          return month[size];

        default:
          return null;
      }
    };
  }

  def_table_by_leap_month() {
    var a, day, i, idx, j, k, l, len, len1, len2, month, month_divs, month_sum, months, range, size, upto, years;
    day = this.calc.msec.day;

    upto = function (src) {
      var i, j, len, msec, results;
      msec = 0;
      results = [];

      for (j = 0, len = src.length; j < len; j++) {
        i = src[j];
        results.push(msec += i * day);
      }

      return results;
    };

    years = _.uniq(this.calc.range.year);
    ({
      months,
      month_divs
    } = this.dic);
    month_sum = 0;

    for (j = 0, len = month_divs.length; j < len; j++) {
      i = month_divs[j];
      month_sum += i;
    }

    range = {
      month: {}
    };

    for (k = 0, len1 = years.length; k < len1; k++) {
      size = years[k];
      a = Array.from(month_divs);
      idx = month_divs.indexOf(0);
      a[idx] = size - month_sum;
      range.month[size] = a;
    }

    month = {};

    for (l = 0, len2 = years.length; l < len2; l++) {
      size = years[l];
      month[size * day] = upto(range.month[size]);
    }

    this.table = {
      range,
      msec: {
        month
      }
    };
    return function ({
      size
    }, path) {
      switch (path) {
        case 'month':
          return month[size];

        default:
          return null;
      }
    };
  }

  def_table_by_season() {
    this.table = {
      range: {},
      msec: {}
    };
    return function (o, path) {
      return null;
    };
  }

  def_table() {
    return this.get_table = this.dic.leaps != null ? this.def_table_by_leap_day() : this.dic.month_divs != null ? this.def_table_by_leap_month() : this.def_table_by_season();
  }

  def_idx() {
    var day, eto, full_period, hour, minute, month, moon, period, ref, season, second, week, year;

    if (this.dic.weeks != null) {
      week = this.dic.weeks.length;
    }

    if (this.dic.etos != null) {
      eto = this.dic.etos.length;
    }

    Object.assign(this.calc.divs, {
      week,
      eto
    });
    [, year, month, day, week, hour, minute, second] = this.dic.start.match(reg_parse);
    year = year - 0;
    month = month - 0;
    day = day - 0;
    hour = hour - 0;
    minute = minute - 0;
    second = second - 0;

    if (this.dic.etos != null) {
      eto = this.dic.etos.idx;
    }

    if (this.dic.weeks != null) {
      week = this.dic.weeks.idx;
    }

    if (this.dic.seasons != null) {
      season = this.dic.seasons.idx;
    }

    moon = 0;

    if (this.dic.leaps != null) {
      ref = this.dic.leaps, [full_period] = slice.call(ref, -1);
      period = full_period;
      Object.assign(this.calc.divs, {
        period
      });
      period = Math.floor(year / this.calc.divs.period);
      year = year % this.calc.divs.period;
    }

    return {
      period,
      year,
      month,
      moon,
      week,
      eto,
      day,
      hour,
      minute,
      second,
      season
    };
  }

  def_zero() {
    var day, era, hour, jd, ld, minute, mjd, month, moon, period, ref, season, second, since, week, year, year_size, zero, zero_size;

    zero_size = (path, idx = 0) => {
      return 0 - (this.calc.idx[path] - idx) * this.calc.msec[path];
    };

    zero = this.dic.start_at - this.dic.tz_offset;
    second = zero + zero_size("second");
    minute = second + zero_size("minute");
    hour = minute + zero_size("hour");
    day = hour + zero_size("day", 1);
    week = day + zero_size("week") / this.calc.divs.week; // JD

    jd = -2440587.5 * this.calc.msec.day;
    ld = jd + 2299159.5 * this.calc.msec.day;
    mjd = jd + 2400000.5 * this.calc.msec.day; // 単純のため平気法。

    season = this.dic.spring + zero_size("season"); // 立春点

    ({
      since
    } = to_tempo_bare(this.calc.msec.year, this.dic.start_at, season));
    season = since + zero_size("year");
    moon = 0 - this.dic.synodic_zero;

    if (this.dic.leaps != null) {
      year_size = this.calc.msec.day * this.table.range.year[modulo(this.calc.idx.year, this.calc.divs.period)];
      month = day - (this.table.msec.month[year_size][this.calc.idx.month - 2] || 0);
      year = month - (this.table.msec.year[this.calc.idx.year - 1] || 0);
      period = year + zero_size("period");
      season += zero_size("period");
    } // 元号


    era = ((ref = this.dic.eras[0]) != null ? ref[1] : void 0) || 2e308;
    this.calc.eras = [];

    if (this.dic.leaps != null) {
      if (period < era) {
        era = period + this.table.msec.year[0];
        this.calc.eras = [[this.dic.era, era, 1]];
      }
    } else {
      if (season < era) {
        era = season + this.calc.msec.year;
        this.calc.eras = [[this.dic.era, era, 1]];
      }
    }

    return {
      period,
      era,
      week,
      season,
      moon,
      day,
      jd,
      ld,
      mjd
    };
  }

  precision() {
    var gap, gaps, idx, j, len, ref, v;
    gaps = [this.calc.msec.year / this.calc.msec.day - this.calc.range.year[0]];

    if (this.dic.leaps) {
      ref = this.dic.leaps;

      for (idx = j = 0, len = ref.length; j < len; idx = ++j) {
        v = ref[idx];
        gap = gaps[gaps.length - 1];

        if (idx % 2) {
          gap += 1 / v;
        } else {
          gap -= 1 / v;
        }

        gaps.push(gap);
      }
    }

    return {
      minute: this.calc.range.second,
      leap: gaps.map(i => {
        return parseInt(1 / i);
      })
    };
  }
  /*
  http://bakamoto.sakura.ne.jp/buturi/2hinode.pdf
  ベクトルで
  a1 = e1 * cos(lat/360) + e3 * sin(lat/360)
  a2 = e3 * cos(lat/360) - e1 * sin(lat/360)
  T = (赤緯, 時角)->
    a1 * sin(赤緯) + cos(赤緯) * (a2 * cos(時角) - e2 * sin(時角))
  T = ( lat, 赤緯, 時角 )->
    e1 * ( cos(lat/360) * sin(赤緯) - sin(lat/360) * cos(赤緯) * cos(時角) ) +
    e2 * (-cos(赤緯) * sin(時角)) +
    e3 * ( sin(lat/360) * sin(赤緯) + cos(lat/360) * cos(赤緯) * cos(時角) )
   K   = @dic.axtial_tilt / 360
  高度 = -50/60
  時角 = ( lat, 高度, 赤緯 )->
    acos(( sin(高度) - sin(lat/360) * sin(赤緯) ) / cos(lat/360) * cos(赤緯) )
  方向 = ( lat, 高度, 赤緯, 時角 )->
    acos(( cos(lat/360) * sin(赤緯) - sin(lat/360) * cos(赤緯) * cos(時角) ) / cos(高度) )
  季節 = 春分点からの移動角度
  赤緯 = asin( sin(K) * sin(季節) )
  赤経 = atan( tan(季節) * cos(K) )
  南中時刻 = ->
    正午 + 時角 + ( 赤経 - 季節 ) + 平均値 + tz_offset
  日の出 = ->
    南中時刻 - 時角
  日の入 = ->
    南中時刻 + 時角
  */


  solor(utc, idx = 2, {
    last_at,
    next_at
  } = to_tempo_bare(this.calc.msec.day, this.calc.zero.day, utc)) {
    var K, PI, T0, T1, acos, asin, atan, cos, days, deg_to_day, deg_to_rad, lat, rad_to_day, sin, spring, tan, year_to_rad, 南中差分A, 南中差分B, 南中時刻, 季節, 方向, 日の入, 日の出, 時角, 真夜中, 赤経, 赤緯, 高度;
    days = [6, // golden hour end         / golden hour
    -18 / 60, // sunrise bottom edge end / sunset bottom edge start
    -50 / 60, // sunrise top edge start  / sunset top edge end
    -6, // dawn                    / dusk
    -12, // nautical dawn           / nautical dusk
    -18 // night end               / night
    ];
    ({
      asin,
      acos,
      atan,
      sin,
      cos,
      tan,
      PI
    } = Math);
    deg_to_rad = 2 * PI / 360;
    year_to_rad = 2 * PI / this.calc.msec.year;
    rad_to_day = this.calc.msec.day / (2 * PI);
    deg_to_day = this.calc.msec.day / 360;
    高度 = days[idx] * deg_to_rad;
    K = this.dic.axtial_tilt * deg_to_rad;
    lat = this.dic.lat * deg_to_rad;
    T0 = to_tempo_bare(this.calc.msec.year, this.calc.zero.season, utc); // 南中差分の計算がテキトウになってしまった。あとで検討。

    南中差分A = Math.floor(2 * deg_to_day * sin(T0.since * year_to_rad));
    南中差分B = Math.floor(2.5 * deg_to_day * sin((T0.since + 1296000000) * year_to_rad * 2));
    南中時刻 = (last_at + next_at) / 2 + 南中差分A + 南中差分B;
    真夜中 = last_at + 南中差分A + 南中差分B;
    T1 = to_tempo_bare(this.calc.msec.year, this.dic.spring, 南中時刻);
    spring = T1.last_at;
    季節 = T1.since * year_to_rad;
    赤緯 = asin(sin(K) * sin(季節));
    赤経 = atan(tan(季節) * cos(K));
    時角 = acos((sin(高度) - sin(lat) * sin(赤緯)) / (cos(lat) * cos(赤緯)));
    方向 = acos((cos(lat) * sin(赤緯) - sin(lat) * cos(赤緯) * cos(時角)) / cos(高度));
    日の出 = Math.floor(南中時刻 - 時角 * rad_to_day);
    日の入 = Math.floor(南中時刻 + 時角 * rad_to_day);
    return {
      T0: [this.calc.msec.year, this.calc.zero.season, utc],
      utc,
      idx,
      高度,
      K,
      lat,
      T1,
      南中差分A,
      南中差分B,
      時角,
      方向,
      last_at,
      真夜中,
      日の出,
      南中時刻,
      日の入,
      next_at
    };
  }

  to_tempo_by_solor(utc, day) {
    var idx, j, k, l, list, msec, next_at, ref, ref1, ref2, ref3, ref4, size, tails, 南中時刻, 日の入, 日の出;
    ({
      日の出,
      南中時刻,
      日の入
    } = this.solor(utc, 2, day));
    size = this.dic.hours.length / 4;
    list = [];
    next_at = 0;
    msec = (日の出 - day.last_at) / size;

    for (idx = j = 0, ref = 1 * size; 0 <= ref ? j < ref : j > ref; idx = 0 <= ref ? ++j : --j) {
      next_at += msec;
      list.push(Math.floor(next_at));
    }

    next_at = 日の出 - day.last_at;
    msec = (日の入 - 日の出) / (2 * size);

    for (idx = k = ref1 = 1 * size, ref2 = 3 * size; ref1 <= ref2 ? k < ref2 : k > ref2; idx = ref1 <= ref2 ? ++k : --k) {
      next_at += msec;
      list.push(Math.floor(next_at));
    }

    next_at = day.size;
    msec = (day.next_at - 日の入) / size;
    tails = [];

    for (idx = l = ref3 = 3 * size, ref4 = 4 * size; ref3 <= ref4 ? l < ref4 : l > ref4; idx = ref3 <= ref4 ? ++l : --l) {
      tails.push(Math.ceil(next_at));
      next_at -= msec;
    }

    list.push(...tails.reverse());
    return to_tempo_by(list, day.last_at, utc);
  }

  to_tempos(utc) {
    var D, E, G, H, J, M, N, N0, N0_p, Nn, S, T, Y, Z, Zs, Zz, center_at, d, drill_down, e, era, era_base, m, now_idx, p, s, size, to_tempo_mod, u, w, w0, y;

    drill_down = (base, path, at = utc) => {
      var b_size, o, table;
      table = this.get_table(base, path);

      if (table) {
        o = to_tempo_by(table, base.last_at, at);
      } else {
        b_size = this.calc.msec[path];
        o = to_tempo_bare(b_size, base.last_at, at);
        o.length = base.size / o.size;
      }

      o.path = path;
      return o;
    };

    to_tempo_mod = (path, sub, write_at = utc) => {
      var do1, do2, do3, last_at, next_at, now_idx, remain, since, size, timeout, zero;
      ({
        now_idx,
        next_at,
        size,
        zero
      } = to_tempo_bare(this.calc.msec[path], this.calc.zero[path], write_at));
      do2 = to_tempo_bare(this.calc.msec[sub], this.calc.zero[sub], next_at);

      if (do2.last_at <= write_at) {
        do3 = to_tempo_bare(this.calc.msec[sub], this.calc.zero[sub], next_at + size);
        now_idx += 1;
        last_at = do2.last_at;
        next_at = do3.last_at;
      } else {
        do1 = to_tempo_bare(this.calc.msec[sub], this.calc.zero[sub], next_at - size);
        last_at = do1.last_at;
        next_at = do2.last_at;
      }

      size = next_at - last_at;
      remain = next_at - write_at;
      since = write_at - last_at;
      timeout = remain;
      return {
        last_at,
        write_at,
        next_at,
        timeout,
        since,
        remain,
        zero,
        now_idx,
        size
      };
    };

    J = to_tempo_bare(this.calc.msec.day, this.calc.zero.jd, utc); // ユリウス日
    // season in year_of_planet

    Zz = to_tempo_bare(this.calc.msec.year, this.calc.zero.season, utc); // 太陽年

    Z = drill_down(Zz, "season"); // 太陽年の二十四節気
    // 正月中気と正月

    N0_p = Zz.last_at + this.calc.msec.season;
    N0 = to_tempo_mod("moon", "day", N0_p); // 今月と中気

    Nn = to_tempo_mod("moon", "day");
    Zs = drill_down(Zz, "season", Nn.last_at);
    center_at = Zs.now_idx & 1 ? Zs.last_at : Zs.next_at;

    if (!(Nn.last_at <= center_at && center_at < Nn.next_at)) {
      Zs = drill_down(Zz, "season", Nn.next_at);
      center_at = Zs.now_idx & 1 ? Zs.last_at : Zs.next_at;

      if (!(Nn.last_at <= center_at && center_at < Nn.next_at)) {
        Nn.is_leap = true;
      }
    }

    switch (Zs.now_idx >> 1) {
      case -1:
        // 太陽年初に0月が出てしまう。昨年末にする。
        Zz = to_tempo_bare(Zz.size, Zz.zero, Zs.last_at);
        break;

      case this.dic.seasons.length >> 1:
        // 太陽年末に13月が出てしまう。年初にする。
        Zz = to_tempo_bare(Zz.size, Zz.zero, Zs.next_at);
    }

    Nn.now_idx = modulo(Zs.now_idx, this.dic.seasons.length) >> 1;
    N = drill_down(Nn, 'day');

    if (this.dic.leaps != null) {
      p = to_tempo_bare(this.calc.msec.period, this.calc.zero.period, utc);
      u = drill_down(p, "year");
      u.now_idx += p.now_idx * this.calc.divs.period;
      M = drill_down(u, "month");
      d = drill_down(M, "day");
    } else {
      u = Zz;
      M = Nn;
      d = N;
    } // day    in week (曜日)


    w0 = to_tempo_bare(this.calc.msec.week, this.calc.zero.week, u.last_at);
    w = drill_down(w0, "week");
    Y = {
      now_idx: u.now_idx
    };

    if (u.next_at < w.next_at) {
      // 年末最終週は、翌年初週
      Y.now_idx += 1;
      w.now_idx = 0;
    }

    e = E = drill_down(w, "day");

    if (this.dic.leaps == null) {
      // 旧暦では、週は月初にリセットする。
      e.now_idx = (M.now_idx + d.now_idx) % this.dic.weeks.length;
    } // day    in year appendix


    D = drill_down(u, "day");

    if (this.dic.is_solor) {
      // hour   in day
      H = this.to_tempo_by_solor(utc, d);
      size = H.size / this.dic.minutes.length;
      m = to_tempo_bare(size, H.last_at, utc);
      s = to_tempo_bare(1000, m.last_at, utc);
    } else {
      // hour   in day
      H = drill_down(d, "hour");
      m = drill_down(H, "minute");
      s = drill_down(m, "second");
    } // minute in day


    now_idx = utc - s.last_at;
    S = {
      now_idx
    };
    T = {
      now_idx: (u.now_idx + this.calc.idx.eto) % this.dic.etos.length
    };
    G = {};

    if (this.table.msec.era != null) {
      era_base = to_tempo_by(this.table.msec.era, this.calc.zero.era, utc);
      era = this.calc.eras[era_base.now_idx];

      if (era != null ? era[0] : void 0) {
        u.now_idx += 1 - era[2];
        G.label = era[0];
      }
    }

    y = Object.assign({}, u);

    if (y.now_idx < 1) {
      G.label = "紀元前";
      y.now_idx = 1 - y.now_idx;
    }

    return {
      G,
      u,
      Y,
      y,
      M,
      d,
      H,
      m,
      s,
      S,
      e,
      E,
      Z,
      N,
      T,
      D,
      w,
      J,
      era
    };
  }

  index(tgt, str = default_parse_format) {
    var H, J, M, S, d, data, f, idx, items, j, len, m, p, reg, s, token, tokens, y;
    p = y = M = d = H = m = s = S = J = 0;
    data = {
      p,
      y,
      M,
      d,
      H,
      m,
      s,
      S,
      J
    };
    tokens = str.match(reg_token);
    idx = this.dic.indexer;
    reg = this.regex(tokens, str);
    items = tgt.match(reg).slice(1);

    for (p = j = 0, len = items.length; j < len; p = ++j) {
      s = items[p];
      token = tokens[p];

      if (f = idx[token[0]]) {
        data[token[0]] = f(s, this.dic.list[token[0]]);
      }
    }

    if (this.dic.leaps != null) {
      data.p = Math.floor(data.y / this.calc.divs.period);
      data.y = data.y - data.p * this.calc.divs.period;
    }

    return data;
  }

  regex(tokens, str) {
    var list, reg, regex;
    ({
      regex,
      list
    } = this.dic);
    reg = "^" + tokens.map(token => {
      var val;

      if (val = regex[token[0]]) {
        return val;
      } else {
        return `(${token.replace(/([\\\[\]().*?])/g, "\\$1")})`;
      }
    }).join("");
    return new RegExp(reg);
  }

  to_label(o, token) {
    var f, list;

    if (f = this.dic.labeler[token[0]]) {
      list = this.dic.list[token[0]];
      return f(o, list, token.length);
    } else {
      return token;
    }
  }

  tempo_list(tempos, token) {
    var base, j, k, last_at, len, length, list, next_at, now_idx, ref, size, table, tempo, zero;

    switch (token[0]) {
      case 'G':
        throw new Error(`request token can't tempos. [${token}]`);
    }

    if (!(tempo = tempos[token[0]])) {
      throw new Error(`request token can't tempos. [${token}]`);
    }

    ({
      table,
      length,
      now_idx,
      last_at,
      size,
      zero
    } = tempo);
    list = [];

    if (table) {
      last_at = zero;

      for (now_idx = j = 0, len = table.length; j < len; now_idx = ++j) {
        next_at = table[now_idx];
        next_at += zero;
        size = next_at - last_at;
        list.push({
          now_idx,
          size,
          last_at,
          next_at,
          last_time: new Date(last_at),
          next_time: new Date(next_at)
        });
        last_at = next_at;
      }
    }

    if (length) {
      base = last_at - size * now_idx;

      for (now_idx = k = 0, ref = length; 0 <= ref ? k < ref : k > ref; now_idx = 0 <= ref ? ++k : --k) {
        last_at = (now_idx + 0) * size + zero;
        next_at = (now_idx + 1) * size + zero;
        list.push({
          now_idx,
          size,
          last_at,
          next_at,
          last_time: new Date(last_at),
          next_time: new Date(next_at)
        });
      }
    }

    return list;
  }

  ranges(utc, token) {
    return this.tempo_list(this.to_tempos(utc), token);
  }

  parse(tgt, str = default_parse_format) {
    var H, J, M, S, d, m, p, s, size, y;
    ({
      p,
      y,
      M,
      d,
      H,
      m,
      s,
      S,
      J
    } = this.index(tgt, str));

    if (J) {
      return this.calc.zero.jd + J * this.calc.msec.day;
    }

    return d * this.calc.msec.day + H * this.calc.msec.hour + m * this.calc.msec.minute + s * this.calc.msec.second + S + (this.dic.leaps != null ? (size = this.table.range.year[y] * this.calc.msec.day, this.calc.zero.period + p * this.calc.msec.period + (this.table.msec.year[y - 1] || 0) + (this.table.msec.month[size][M - 1] || 0)) : this.calc.zero.season + y * this.calc.msec.year + M * this.calc.msec.month);
  }

  format(utc, str = default_format_format) {
    var o;
    o = this.to_tempos(utc);
    return str.match(reg_token).map(token => {
      var val;

      if (val = o[token[0]]) {
        return this.to_label(val, token);
      } else {
        return token;
      }
    }).join("");
  }

};
exports.FancyDate = FancyDate;
module.exports = FancyDate;

/***/ }),

/***/ "./src/index.coffee":
/*!**************************!*\
  !*** ./src/index.coffee ***!
  \**************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


__webpack_require__(/*! ./sample */ "./src/sample.coffee");

module.exports = {
  FancyDate: __webpack_require__(/*! ./fancy-date */ "./src/fancy-date.coffee"),
  ...__webpack_require__(/*! ./time */ "./src/time.coffee")
};

/***/ }),

/***/ "./src/sample.coffee":
/*!***************************!*\
  !*** ./src/sample.coffee ***!
  \***************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var FancyDate, FastEarth, GREGORIO, MARS_GREGORIO, ROMULUS, a, b, g, idx, 七曜, 二十四節季, 元号, 六十干支, 六十干支よみ, 六曜, 十二支, 十干, 和風月名, 地球, 平気法, 日本, 時の鐘, 月相, 火星;
FancyDate = __webpack_require__(/*! ./fancy-date */ "./src/fancy-date.coffee");
七曜 = ['月', '火', '水', '木', '金', '土', '日'];
六曜 = ["先勝", "友引", "先負", "仏滅", "大安", "赤口"];
和風月名 = ['睦月', '如月', '弥生', '卯月', '皐月', '水無月', '文月', '葉月', '長月', '神無月', '霜月', '師走'];
二十四節季 = ["立春", "雨水", "啓蟄", "春分", "清明", "穀雨", "立夏", "小満", "芒種", "夏至", "小暑", "大暑", "立秋", "処暑", "白露", "秋分", "寒露", "霜降", "立冬", "小雪", "大雪", "冬至", "小寒", "大寒"];
月相 = ['朔', '既朔', '三日月', '上弦', '上弦', '上弦', '上弦', '上弦', '上弦', '上弦', '上弦', '上弦', '十三夜', '小望月', '満月', '十六夜', '立待月', '居待月', '臥待月', '更待月', '下限', '下限', '下限', '下限', '下限', '下限', '下限', '下限', '晦', '晦'];
時の鐘 = ['夜九つ', '夜八つ', '暁七つ', '明六つ', '朝五つ', '昼四つ', '昼九つ', '昼八つ', '夕七つ', '暮六つ', '宵五つ', '夜四つ'];
十干 = [["甲", "きのえ"], ["乙", "きのと"], ["丙", "ひのえ"], ["丁", "ひのと"], ["戊", "つちのえ"], ["己", "つちのと"], ["庚", "かのえ"], ["辛", "かのと"], ["壬", "みずのえ"], ["癸", "みずのと"]];
十二支 = [["子", "ね"], ["丑", "うし"], ["寅", "とら"], ["卯", "う"], ["辰", "たつ"], ["巳", "み"], ["午", "うま"], ["未", "ひつじ"], ["申", "さる"], ["酉", "とり"], ["戌", "いぬ"], ["亥", "い"]];

六十干支 = function () {
  var i, results;
  results = [];

  for (idx = i = 0; i < 60; idx = ++i) {
    a = 十干[idx % 十干.length];
    b = 十二支[idx % 十二支.length];
    results.push(`${a[0]}${b[0]}`);
  }

  return results;
}();

六十干支よみ = function () {
  var i, results;
  results = [];

  for (idx = i = 0; i < 60; idx = ++i) {
    a = 十干[idx % 十干.length];
    b = 十二支[idx % 十二支.length];
    results.push(`${`${a[1].replace(/と$/, "との")}${b[1]}`}`);
  }

  return results;
}();

元号 = [["大化", -41795611200000 - 75600000], ["白雉", -41647953600000 - 75600000], ["朱鳥", -40499352000000 - 75600000], ["大宝", -40034865600000 - 75600000], ["慶雲", -39936369600000 - 75600000], ["和銅", -39821371200000 - 75600000], ["霊亀", -39579883200000 - 75600000], ["養老", -39509640000000 - 75600000], ["神亀", -39314289600000 - 75600000], ["天平", -39140712000000 - 75600000], ["天平感宝", -38520014400000 - 75600000], ["天平勝宝", -38510769600000 - 75600000], ["天平宝字", -38256753600000 - 75600000], ["天平神護", -38023041600000 - 75600000], ["神護景雲", -37940616000000 - 75600000], ["宝亀", -37842465600000 - 75600000], ["天応", -37518292800000 - 75600000], ["延暦", -37465761600000 - 75600000], ["大同", -36718228800000 - 75600000], ["弘仁", -36580420800000 - 75600000], ["天長", -36160603200000 - 75600000], ["承和", -35844465600000 - 75600000], ["嘉祥", -35389483200000 - 75600000], ["仁寿", -35298763200000 - 75600000], ["斉衡", -35186356800000 - 75600000], ["天安", -35115681600000 - 75600000], ["貞観", -35047339200000 - 75600000], ["元慶", -34478222400000 - 75600000], ["仁和", -34232846400000 - 75600000], ["寛平", -34099704000000 - 75600000], ["昌泰", -33816571200000 - 75600000], ["延喜", -33712977600000 - 75600000], ["延長", -33026875200000 - 75600000], ["承平", -32775537600000 - 75600000], ["天慶", -32551416000000 - 75600000], ["天暦", -32270702400000 - 75600000], ["天徳", -31938667200000 - 75600000], ["応和", -31834987200000 - 75600000], ["康保", -31725864000000 - 75600000], ["安和", -31597905600000 - 75600000], ["天禄", -31545892800000 - 75600000], ["天延", -31428907200000 - 75600000], ["貞元", -31347864000000 - 75600000], ["天元", -31272523200000 - 75600000], ["永観", -31133419200000 - 75600000], ["寛和", -31071124800000 - 75600000], ["永延", -31009262400000 - 75600000], ["永祚", -30935044800000 - 75600000], ["正暦", -30896856000000 - 75600000], ["長徳", -30760344000000 - 75600000], ["長保", -30638606400000 - 75600000], ["寛弘", -30464510400000 - 75600000], ["長和", -30196152000000 - 75600000], ["寛仁", -30061108800000 - 75600000], ["治安", -29940494400000 - 75600000], ["万寿", -29832408000000 - 75600000], ["長元", -29706264000000 - 75600000], ["長暦", -29430993600000 - 75600000], ["長久", -29317204800000 - 75600000], ["寛徳", -29190974400000 - 75600000], ["永承", -29145873600000 - 75600000], ["天喜", -28934366400000 - 75600000], ["康平", -28756814400000 - 75600000], ["治暦", -28537185600000 - 75600000], ["延久", -28421409600000 - 75600000], ["承保", -28252152000000 - 75600000], ["承暦", -28150545600000 - 75600000], ["永保", -28046606400000 - 75600000], ["応徳", -27952516800000 - 75600000], ["寛治", -27852984000000 - 75600000], ["嘉保", -27609854400000 - 75600000], ["永長", -27548424000000 - 75600000], ["承徳", -27517492800000 - 75600000], ["康和", -27463320000000 - 75600000], ["長治", -27321969600000 - 75600000], ["嘉承", -27253195200000 - 75600000], ["天仁", -27179755200000 - 75600000], ["天永", -27120139200000 - 75600000], ["永久", -27023284800000 - 75600000], ["元永", -26876059200000 - 75600000], ["保安", -26811691200000 - 75600000], ["天治", -26684683200000 - 75600000], ["大治", -26629560000000 - 75600000], ["天承", -26470670400000 - 75600000], ["長承", -26421336000000 - 75600000], ["保延", -26335627200000 - 75600000], ["永治", -26140708800000 - 75600000], ["康治", -26116084800000 - 75600000], ["天養", -26057937600000 - 75600000], ["久安", -26014564800000 - 75600000], ["仁平", -25840728000000 - 75600000], ["久寿", -25720718400000 - 75600000], ["保元", -25674840000000 - 75600000], ["平治", -25581009600000 - 75600000], ["永暦", -25556385600000 - 75600000], ["応保", -25505928000000 - 75600000], ["長寛", -25455211200000 - 75600000], ["永万", -25385918400000 - 75600000], ["仁安", -25348248000000 - 75600000], ["嘉応", -25265649600000 - 75600000], ["承安", -25200763200000 - 75600000], ["安元", -25067534400000 - 75600000], ["治承", -25003252800000 - 75600000], ["養和", -24877368000000 - 75600000], ["寿永", -24850756800000 - 75600000], ["元暦", -24790449600000 - 75600000], ["文治", -24749841600000 - 75600000], ["建久", -24602097600000 - 75600000], ["正治", -24317496000000 - 75600000], ["建仁", -24259953600000 - 75600000], ["元久", -24164913600000 - 75600000], ["建永", -24095448000000 - 75600000], ["承元", -24049742400000 - 75600000], ["建暦", -23941396800000 - 75600000], ["建保", -23854910400000 - 75600000], ["承久", -23685998400000 - 75600000], ["貞応", -23591476800000 - 75600000], ["元仁", -23509310400000 - 75600000], ["嘉禄", -23496523200000 - 75600000], ["安貞", -23413147200000 - 75600000], ["寛喜", -23375304000000 - 75600000], ["貞永", -23278622400000 - 75600000], ["天福", -23244321600000 - 75600000], ["文暦", -23196715200000 - 75600000], ["嘉禎", -23167425600000 - 75600000], ["暦仁", -23067633600000 - 75600000], ["延応", -23061326400000 - 75600000], ["仁治", -23017176000000 - 75600000], ["寛元", -22934664000000 - 75600000], ["宝治", -22806878400000 - 75600000], ["建長", -22741387200000 - 75600000], ["康元", -22505342400000 - 75600000], ["正嘉", -22491691200000 - 75600000], ["正元", -22426891200000 - 75600000], ["文応", -22392331200000 - 75600000], ["弘長", -22366238400000 - 75600000], ["文永", -22271112000000 - 75600000], ["建治", -21919204800000 - 75600000], ["弘安", -21829694400000 - 75600000], ["正応", -21508286400000 - 75600000], ["永仁", -21341880000000 - 75600000], ["正安", -21161563200000 - 75600000], ["乾元", -21049675200000 - 75600000], ["嘉元", -21025483200000 - 75600000], ["徳治", -20920075200000 - 75600000], ["延慶", -20861841600000 - 75600000], ["応長", -20783563200000 - 75600000], ["正和", -20753668800000 - 75600000], ["文保", -20599531200000 - 75600000], ["元応", -20531016000000 - 75600000], ["元亨", -20472782400000 - 75600000], ["正中", -20354068800000 - 75600000], ["嘉暦", -20309227200000 - 75600000], ["元徳", -20204424000000 - 75600000], ["元弘", -20142302400000 - 75600000], ["正慶", -20120270400000 - 75600000], ["建武", -20064024000000 - 75600000], ["延元", -19997668800000 - 75600000], ["興国", -19867636800000 - 75600000], ["正平", -19657598400000 - 75600000], ["建徳", -18913780800000 - 75600000], ["文中", -18859867200000 - 75600000], ["天授", -18760420800000 - 75600000], ["弘和", -18580708800000 - 75600000], ["元中", -18479707200000 - 75600000], ["暦応", -19918785600000 - 75600000], ["康永", -19803960000000 - 75600000], ["貞和", -19694836800000 - 75600000], ["観応", -19556510400000 - 75600000], ["文和", -19474862400000 - 75600000], ["延文", -19364961600000 - 75600000], ["康安", -19206763200000 - 75600000], ["貞治", -19161403200000 - 75600000], ["応安", -18990849600000 - 75600000], ["永和", -18768110400000 - 75600000], ["康暦", -18640929600000 - 75600000], ["永徳", -18579499200000 - 75600000], ["至徳", -18484891200000 - 75600000], ["嘉慶", -18373003200000 - 75600000], ["康応", -18328161600000 - 75600000], ["明徳", -18293515200000 - 75600000], ["応永", -18157608000000 - 75600000], ["正長", -17089185600000 - 75600000], ["永享", -17047713600000 - 75600000], ["嘉吉", -16686907200000 - 75600000], ["文安", -16593595200000 - 75600000], ["宝徳", -16420708800000 - 75600000], ["享徳", -16326532800000 - 75600000], ["康正", -16229592000000 - 75600000], ["長禄", -16162977600000 - 75600000], ["寛正", -16058952000000 - 75600000], ["文正", -15897643200000 - 75600000], ["応仁", -15863860800000 - 75600000], ["文明", -15795518400000 - 75600000], ["長享", -15222168000000 - 75600000], ["延徳", -15155726400000 - 75600000], ["明応", -15064056000000 - 75600000], ["文亀", -14792760000000 - 75600000], ["永正", -14698238400000 - 75600000], ["大永", -14145278400000 - 75600000], ["享禄", -13926081600000 - 75600000], ["天文", -13800283200000 - 75600000], ["弘治", -13068475200000 - 75600000], ["永禄", -12993998400000 - 75600000], ["元亀", -12609259200000 - 75600000], ["天正", -12506788800000 - 75600000], ["文禄", -11896113600000 - 75600000], ["慶長", -11772043200000 - 75600000], ["元和", -11181326400000 - 75600000], ["寛永", -10909425600000 - 75600000], ["正保", -10254859200000 - 75600000], ["慶安", -10152907200000 - 75600000], ["承応", -10009742400000 - 75600000], ["明暦", -9928526400000 - 75600000], ["万治", -9825624000000 - 75600000], ["寛文", -9738705600000 - 75600000], ["延宝", -9346190400000 - 75600000], ["天和", -9092865600000 - 75600000], ["貞享", -9017006400000 - 75600000], ["元禄", -8873409600000 - 75600000], ["宝永", -8384990400000 - 75600000], ["正徳", -8159313600000 - 75600000], ["享保", -7996363200000 - 75600000], ["元文", -7370654400000 - 75600000], ["寛保", -7217726400000 - 75600000], ["延享", -7123809600000 - 75600000], ["寛延", -6986865600000 - 75600000], ["宝暦", -6880939200000 - 75600000], ["明和", -6485054400000 - 75600000], ["安永", -6218510400000 - 75600000], ["天明", -5954299200000 - 75600000], ["寛政", -5707454400000 - 75600000], ["享和", -5326430400000 - 75600000], ["文化", -5231476800000 - 75600000], ["文政", -4784097600000 - 75600000], ["天保", -4384497600000 - 75600000], ["弘化", -3943857600000 - 75600000], ["嘉永", -3842078400000 - 75600000], ["安政", -3627806400000 - 75600000], ["万延", -3462782400000 - 75600000], ["文久", -3432110400000 - 75600000], ["元治", -3337588800000 - 75600000], ["慶応", -3303028800000 - 75600000], ["明治", -3216715200000 - 75600000], ["大正", -1812110400000 - 75600000], ["昭和", -1357560000000 - 75600000], ["平成", 600264000000 - 75600000], ["令和", 1556712000000 - 75600000]]; // 号, 開始時刻

日本 = [35, 135];
地球 = [[31556925147.0, new Date("2019/03/21 06:58").getTime()], [2551442889.6, new Date("2019/01/06 10:28").getTime()], [86400000, 0 // LOD ではなく、暦上の1日。Unix epoch では閏秒を消し去るため。
], 23.4397, 日本];
GREGORIO = {
  calendar: ["1970年1月1日(木)0時0分0秒", 0, [4, 100, 400], [31, 0, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]],
  rolls: [["曜", 3, 七曜], ["", 56, 六十干支, 六十干支よみ]],
  yeary: [["月", 0, 12], ["日", 0]],
  //   節    中     節    中     節    中 
  seasonly: [["", 3, 二十四節季]],
  moony: [["", 0, 月相]],
  daily: [["時", 0, 24], ["分", 0, 60], ["秒", 0]]
};
平気法 = {
  calendar: ["1970年1月1日(木)0時0分0秒", 0],
  rolls: [["", null, 六曜], ["", 0, 六十干支, 六十干支よみ]],
  yeary: [["月", 0, 和風月名], ["日", 0]],
  daily: [["時", 0, 時の鐘], ["分", 0, ['', '半']], ["秒", 0], true]
};
ROMULUS = {
  calendar: ["1970年1月1日(木)0時0分0秒", 0, null, [0, 31, 30, 31, 30, 31, 30, 30, 31, 30, 30]],
  rolls: [["", 0, "ABCDEFGH"], ["", 0, 六十干支, 六十干支よみ]]
};
FastEarth = [// 天体が地球の百倍速のケース
[315569251.470, new Date("2019/03/21 06:58").getTime() / 100], [25514428.896, new Date("2019/01/06 10:28").getTime() / 100], [864000, 0 // LOD ではなく、暦上の1日。Unix epoch では閏秒を消し去るため。
], 23.4397, 日本];
FancyDate.Gregorian = g = new FancyDate().planet(...地球).calendar(...GREGORIO.calendar).rolls(...GREGORIO.rolls).era("西暦").yeary(...GREGORIO.yeary).seasonly(...GREGORIO.seasonly).moony(...GREGORIO.moony).daily(...GREGORIO.daily).init();
FancyDate.平気法 = FancyDate.Gregorian.dup().planet(...地球).calendar(...平気法.calendar).rolls(...平気法.rolls).era("西暦", 元号).yeary(...平気法.yeary).daily(...平気法.daily).init(); //FancyDate.Romulus = FancyDate.Gregorian.dup()
//  .calendar ...ROMULUS.calendar
// .rolls    ...ROMULUS.rolls
//  .init()

FancyDate.Fast = FancyDate.Gregorian.dup().planet(...FastEarth).era("fast", 元号).init();
火星 = [[59354347573.5373, new Date("2018/10/28 09:00").getTime()], null, [88775000, 0 // 24時間39分35秒。
], 25.19, [35, 0]];
MARS_GREGORIO = {
  calendar: ["1年1月1日(木)0時0分0秒", g.parse("0年9月1日"), // 春分が３月くらいになるよう、恣意的に決めました。
  [1, 2, 10, 100, 300]],
  yeary: [["月", 1, 12], ["日", 1]],
  daily: [["時", 0, 24], ["分", 0, 62], ["秒", 0]]
};
FancyDate.MarsGregorian = FancyDate.Gregorian.dup().planet(...火星).calendar(...MARS_GREGORIO.calendar).era("西暦").yeary(...MARS_GREGORIO.yeary).daily(...MARS_GREGORIO.daily).init();

/***/ }),

/***/ "./src/time.coffee":
/*!*************************!*\
  !*** ./src/time.coffee ***!
  \*************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var Tempo,
    m,
    to_msec,
    to_sec,
    to_tempo_bare,
    to_tempo_by,
    splice = [].splice;
Tempo = class Tempo {
  constructor(...args) {
    var callback, ref;
    ref = args, [...args] = ref, [callback] = splice.call(args, -1);
    this.args = args;
    this.callback = callback;
    this.tempo = to_tempo(this.args[0], this.args[1], new Date(0));
  }

  tick() {
    var tempo;
    tempo = to_tempo(...this.args);

    if (this.tempo.now_idx === tempo.now_idx) {
      return;
    }

    this.callback(tempo);
    return this.tempo = tempo;
  }

};

to_msec = function (str) {
  return 1000 * to_sec(str);
};

to_sec = function (str) {
  var timeout;
  timeout = 0;
  str.replace(/(\d+)([ヵ]?([smhdwy秒分時日週月年])[間]?(半$)?)|0/g, function (full, num, fullunit, unit, appendix) {
    if (!(num = Number(num))) {
      return null;
    }

    if ('半' === appendix) {
      num += 0.5;
    }

    return timeout += num * function () {
      switch (unit) {
        case "s":
        case "秒":
          return 1;

        case "m":
        case "分":
          return 60;

        case "h":
        case "時":
          return 3600;

        case "d":
        case "日":
          return 3600 * 24;

        case "w":
        case "週":
          return 3600 * 24 * 7;

        case "y":
        case "年":
          return 31556925.147;
        // 2019 average.

        default:
          throw new Error(`${str} at ${num}${unit}`);
      }
    }();
  });
  return timeout;
};

to_tempo_bare = function (size, zero, write_at) {
  var last_at, next_at, now_idx, remain, since, timeout;
  now_idx = Math.floor((write_at - zero) / size);
  last_at = (now_idx + 0) * size + zero;
  next_at = (now_idx + 1) * size + zero;
  remain = next_at - write_at;
  since = write_at - last_at;
  timeout = remain;
  return {
    last_at,
    write_at,
    next_at,
    timeout,
    since,
    remain,
    zero,
    now_idx,
    size
  };
};
/*
to_tempo_by = (table, zero, write_at)->
scan_at = write_at - zero
if scan_at < 0
  now_idx = -1
  next_at = zero
  last_at = -Infinity
else
  last_at = 0
  for next_at, now_idx in table
    unless scan_at < next_at
      last_at = next_at
      continue
    break

  if last_at == next_at
    next_at = Infinity
  next_at += zero
  last_at += zero

size   =  next_at -  last_at
remain =  next_at - write_at
since  = write_at -  last_at
timeout = remain

{ last_at, write_at, next_at, timeout, now_idx, remain, since, zero, size, scan_at, table }
*/
// バイナリサーチ 高速化はするが、微差なので複雑さのせいで逆に遅いかも？


to_tempo_by = function (table, zero, write_at) {
  var last_at, mid_idx, next_at, now_idx, remain, scan_at, since, size, timeout, top_idx;
  scan_at = write_at - zero;

  if (scan_at < 0) {
    now_idx = -1;
    next_at = zero;
    last_at = -2e308;
  } else {
    top_idx = 0;
    now_idx = table.length;

    while (top_idx < now_idx) {
      mid_idx = top_idx + now_idx >>> 1;
      next_at = table[mid_idx];

      if (next_at <= scan_at) {
        top_idx = mid_idx + 1;
      } else {
        now_idx = mid_idx;
      }
    }

    next_at = table[now_idx] || 2e308;
    last_at = table[now_idx - 1] || 0;
    next_at += zero;
    last_at += zero;
  }

  size = next_at - last_at;
  remain = next_at - write_at;
  since = write_at - last_at;
  timeout = remain;
  return {
    last_at,
    write_at,
    next_at,
    timeout,
    now_idx,
    remain,
    since,
    zero,
    size,
    table
  };
};

module.exports = m = {
  Tempo,
  to_msec,
  to_sec,
  to_tempo_bare,
  to_tempo_by
};

/***/ }),

/***/ "lodash":
/*!*************************!*\
  !*** external "lodash" ***!
  \*************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = require("lodash");

/***/ })

/******/ });
});
//# sourceMappingURL=index.min.js.map